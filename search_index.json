[
["index.html", "Statistički softver 1 Predgovor Pre nego li počnemo… R / Rstudio Github", " Statistički softver 1 Blagoje Ivanović Poslednja izmena: 18 November, 2019 Predgovor Na ovoj stranici će se nalaziti materijali za statistički softver 1. Cilj kursa je da se upoznamo sa osnovnim, ali i naprednijim konceptima programiranja u jeziku R. Takodje, insistiraćemo na praćenju dobrih praksi u kodiranju i kroz kurs ćemo se upoznati sa nekim često korišćenim alatima u programerskoj zajednici. Kurs će biti praktično orijentisan i ovaj dokument će ličiti na zbirku zadataka iz R-a, gde ćemo implementirati razne funkcije i kroz praksu se suočiti sa čestim problemima u R programiranju i videti kako se rešavaju. Na ovoj stranici je zapisan okvirni plan kursa (koji će se verovatno menjati usput), u malo lepšem formatu. Korisna literatura Klasičnija literatura koja je od koristi kao uvodni materijal je knjiga R for Dummies. Tu su metodično opisane mogučnosti R-a i česte radnje u njemu. Za one koji bi da nauče dosta više o R-u, obavezna literatura je Advanced R. Takodje, koristićemo i meni posebno dragu knjigu R Inferno, u kojoj su izlistani česti problemi koji se javljaju u radu sa R-om, a vrlo ih je lako prevideti. Pre nego li počnemo… R / Rstudio Pre praćenja materijala, naravano, potrebno je instalirati R i Rstudio, što je opisano na ovim linkovima: uwaterloo.ca i rstudio-education.github.io. Github Takodje, seminarski će se predavati putem Github platforme, koja je najveća platforma koju programeri koriste za deljenje svog koda, kao deo “open source” zajednice. Stoga je za potrebe kursa neophodno da svi naprave nalog na Github.com. "],
["01-uvod.html", "1 Početni koraci 1.1 Primitivni tipovi 1.2 Vektori 1.3 Matrice 1.4 Liste", " 1 Početni koraci U ovom poglavlju proći ćemo kroz osnovne strukture podataka u R-u. Pored ovoga, dobar pregled nekih osnovnih stvari koje se mogu raditi u R-u se može videti u materijalima koleginice Tamare Milić. 1.1 Primitivni tipovi 1.1.1 Logicki tip - logical (true/false) 1 == 1 ## [1] TRUE 2 == 3 ## [1] FALSE Pisu se velikim slovima, 2 vrednosti - TRUE, FALSE False # ne postoji objekat FALSE Kao uvek, 0 je FALSE 0 == FALSE # TRUE ## [1] TRUE Postoje operatori kao u drugim jezicima !, &amp;&amp;, || !(FALSE || TRUE) &amp;&amp; FALSE ## [1] FALSE 1.1.2 Brojevi - numeric (interno uvek double) 5 + 6 ## [1] 11 3 / 2 # = 1.5, tj. brojevi su po default-u double, pa nema problema ## [1] 1.5 sa celobrojnim deljenjem class(5) ## [1] &quot;numeric&quot; 1.1.3 Celi brojevi - integer (interno int (mozda long)): 5L ## [1] 5 class(5L) ## [1] &quot;integer&quot; 5L / 3L # deljenje opet gleda kao realno, mora se precizirati da ## [1] 1.666667 zelimo celobrojno deljenje operator celobrojnog deljenja je 5 %/% 3 ## [1] 1 mozemo i da promenimo klasu broja u integer as.integer(5 / 3) ## [1] 1 Operacije nad brojevima koje su moguce su: +, -, *, /, %/%, %%, ^ 4 %% 5 # ostatak pri deljenju ## [1] 4 4 ^ 5 # stepenovanje ## [1] 1024 sve je slicno matlabu postoje ugradjene funkcije exp, sin, cos, tan, atan, asin, itd. sin(log(exp(pi))) ## [1] 1.224647e-16 rezultat ovoga nije bas nula, vec 1.22e-16 = 1.22 * 10^(-16) standardna prica sa poredjenjem double/float vrednosti stoji sin(log(exp(pi))) == 0 # FALSE ## [1] FALSE abs(sin(log(exp(pi)))) &lt; 1e-10 # TRUE, za neku toleranciju ## [1] TRUE 1.1.4 Stringovi - character (ne postoji razlika izmedju stringa i karaktera, sve su stringovi) class(&quot;softveri&quot;) ## [1] &quot;character&quot; 1.1.4.1 Neke korisne funkcije za stringove spajanje: paste(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a b&quot; paste0(&quot;a&quot;, &quot;b&quot;) # spaja bez razmaka ## [1] &quot;ab&quot; paste(&quot;Ja&quot;, &quot;matf&quot;, sep = &quot; &lt;3 &quot;) # sep oznacava separator ## [1] &quot;Ja &lt;3 matf&quot; paste(1, 2, 3, sep = &quot; &lt; &quot;) # ako stavimo npr broj, pretvorice se u string ## [1] &quot;1 &lt; 2 &lt; 3&quot; c stil formatiranja sprintf(&quot;Broj %d. Izvucen je broj %d.&quot;, 7, 8) ## [1] &quot;Broj 7. Izvucen je broj 8.&quot; sprintf(&quot;Broj %.2f.&quot;, pi) # pi postoji kao konstanta, e ne postoji vec exp(1) ## [1] &quot;Broj 3.14.&quot; 1.1.4.2 glue - korisna biblioteka za rad sa stringovima stringova # install.packages(&quot;glue&quot;) # ovako se instaliraju paketi. library(glue) # ovako se ucitavaju paketi glue(&quot;{who} &lt;3 {what}&quot;, who = &quot;Ja&quot;, what = &quot;fon&quot;) ## Ja &lt;3 fon glue(&quot;{number} == {number}&quot;, number = 17) ## 17 == 17 istrazite sami paket, premocan je 1.2 Vektori vektori se prave sa funkcijom c (c = combine) c(1, 2, 3) ## [1] 1 2 3 precica za vektore ovog tipa: 1:3 ## [1] 1 2 3 c(1, 3, 45, 65) ## [1] 1 3 45 65 sve operacije nad brojevima mogu se primeniti i na vektore i primenjuju se element po element. Ako znate matlab, razlika je sto su u R sve operacije nad vektorima rade element po element, a za matricno mnozenje i slicno se koriste posebni operatori. Znaci a * b u R je isto kao a .* b u MATLAB c(1, 2) + c(3, 4) ## [1] 4 6 a &lt;- 1:10 # operator dodele je &lt;- b &lt;- 11:20 a * b ## [1] 11 24 39 56 75 96 119 144 171 200 a + b ## [1] 12 14 16 18 20 22 24 26 28 30 a ^ b ## [1] 1.000000e+00 4.096000e+03 1.594323e+06 2.684355e+08 3.051758e+10 ## [6] 2.821110e+12 2.326305e+14 1.801440e+16 1.350852e+18 1.000000e+20 Nad vektorima postoje razne funkcije poput sum, mean, var, sd, median, itd., a i sve elementarne funkcije koje postoje nad brojevima su vektorizovane za vektore, pa je npr. sin(c(1, 2)) = c(sin(1), sin(2)) sin(a) ## [1] 0.8414710 0.9092974 0.1411200 -0.7568025 -0.9589243 -0.2794155 ## [7] 0.6569866 0.9893582 0.4121185 -0.5440211 vektori mogu sadrzati elemente samo jednog primitivnog tipa c(1, 2) ## [1] 1 2 c(1L, 2L) ## [1] 1 2 c(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a&quot; &quot;b&quot; c(&quot;a&quot;, 2) ## [1] &quot;a&quot; &quot;2&quot; c(TRUE, FALSE) ## [1] TRUE FALSE Ukoliko se tipovi ne slazu, pretvorice se u najfleksibilniji tip, znaci logical -&gt; integer -&gt; numeric -&gt; character class(c(TRUE, 1L, 1, &quot;1&quot;)) ## [1] &quot;character&quot; I logicki operatori su vektorizovani, pa je 1:5 &lt;= c(1, 1, 2, 2, 5) # TRUE FALSE FALSE FALSE TRUE ## [1] TRUE FALSE FALSE FALSE TRUE postoje funkcije any, all kao u MATLAB-u any(rep(2, 3) &lt; 1:3) ## [1] TRUE all(rep(2, 3) &lt; 1:3) ## [1] FALSE Kad su logicki vektori u pitanju obratiti paznju na &amp; i &amp;&amp;, kao i | i || R INFERNO and and andand A &lt;- c(FALSE, TRUE, TRUE, FALSE) B &lt;- c(TRUE, FALSE, TRUE, FALSE) &amp; i | rade vektorski - element po element i vracaju vektor! A &amp; B ## [1] FALSE FALSE TRUE FALSE A | B ## [1] TRUE TRUE TRUE FALSE &amp;&amp; i || porede samo prve elemente A &amp;&amp; B ## [1] FALSE A || B ## [1] TRUE 1.3 Matrice matrice se prave funckijom matrix matrix(1:9, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 prvi argument oznacava elemente koje ce sadrzati, to je jedan vektor, pri cemu se u matricu upisuju po kolonama, ukoliko nije specificirano drugacije. nrow argument (ili ncol) specifikuju koliko vrsta ima matrica. matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 za lepsi zapis moze se koristiti byrow = TRUE i pisati ovako matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), byrow = TRUE, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 2 2 2 ## [3,] 3 3 3 Sve elementarne funkcije nad matricama rade kao nad vektorima, znaci vracaju matricu, a primenjuju funkciju na svaki element. Mnozenje matrica se radi operatorom %*%, transponovanje funkcijom t() A &lt;- matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), byrow = TRUE, nrow = 3) t(A) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 A %*% A ## [,1] [,2] [,3] ## [1,] 6 6 6 ## [2,] 12 12 12 ## [3,] 18 18 18 Skalarno mnozenje se moze implementirati na vise nacina, npr u &lt;- c(1, 2, 3) v &lt;- c(4, 5, 6) sum(u * v) ## [1] 32 ili mnozenjem uTv t(u) %*% v ## [,1] ## [1,] 32 Primetimo da poslednji izraz vraca 1x1 matricu, a prvi vraca broj, tj vektor velicine 1. Sa as.numeric mozemo to srediti. as.numeric(t(u) %*% v) ## [1] 32 Vektori kad se tumace kao matrice su naravno kolone vektori. 1.4 Liste Liste su nizovi koji mogu da sadrze objekte razlicitih tipova. Prakticno mogu da sadrze kao svoje elemente bilo koji objekat u R-u: vektore, matrice, druge liste, itd. n &lt;- c(2, 3, 5) s &lt;- c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;, &quot;ee&quot;) b &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) lst &lt;- list(n, s, b) # lst sadrzi kopije od n, s, b lst[1] #niz n ## [[1]] ## [1] 2 3 5 lst[2] #niz s ## [[1]] ## [1] &quot;aa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot; &quot;ee&quot; Na ovaj način dobijamo kopije prvog, odnosno drugog člana liste Međutim ako hoćemo da direktno pristupimo članu liste koristimo [[ ]] lst[[1]] ## [1] 2 3 5 Tada možemo da menjamo sadržaj liste lst[[2]]&lt;-c(&quot;a&quot;,&quot;b&quot;) lst[[2]][1]&lt;-&quot;c&quot; Liste mogu imati i imena clanova, kojima se onda moze pristupati dolarima $. named_list &lt;- list(brojevi = 1:5, slova = c(&quot;a&quot;, &quot;b&quot;)) named_list$brojevi ## [1] 1 2 3 4 5 named_list[[1]] ## [1] 1 2 3 4 5 "],
["03-matsum.html", "2 Matrix summary 2.1 Implementacija funkcije matrix_summary 2.2 Provera dijagonalnosti", " 2 Matrix summary Napravicemo funkciju ciji cilj je da odredi osnovna svojstva matrice, poput dimenzije, ranga, sopstvenih vrednosti, invertibilnosti, dijagonalnosti i slicno. Nakon toga napravicemo i funkciju koja stampa sazetak osnovnih svojstava matrice u lepom formatu, sa glue bibliotekom. Pisacemo red po red funkcije, uz detaljna objasnjenja, pa na kraju dati kompletan kod. 2.1 Implementacija funkcije matrix_summary Definisimo prvo funkciju, primace argument mat koji predstavlja matricu matrix_summary &lt;- function(mat) { # ... Izlaz ce nam biti lista koja sadrzi trazena svojstva matrice. Biramo listu kao izlazni tip, jer zelimo da skladistimo objekte raznih dimenzija i tipova, pa se ne mozemo zadovoljiti vektorskim tipom. Dakle, kreiramo praznu listu, koju cemo dalje popunjavati. output &lt;- list() Za pocetak dodacemo u listu izlaza matricu koju analiziramo, kao i dimenzije output$matrix &lt;- mat output$dimensions &lt;- dim(mat) Sledeci je rang matrice. Njega cemo racunati pomocu funkcije rankMatrix iz Matrix paketa library(Matrix) output$rank &lt;- rankMatrix(mat) Da li je matrica kvadratna cemo proveriti uporedjivanjem dimenzija matrice. Ukoliko je razlika broja kolona i vrsta jednaka 0, to znaci da je matrica kvadratna. output$is_square &lt;- diff(dim(mat)) == 0 Dalja svojstva matrice koja cemo gledati su: kvadratnost, inveritbilnost, inverz, sopstvene vrednosti, simetricnost i dijagonalnosti. Ova svojstva imaju smisla samo za kvadratne matrice, pa ce to biti uslov da razmatramo ova svojstva. if (output$is_square) { # ... Da li je matrica singularna (tj. nema inverz) proveravamo tako sto pogledamo da li je rang matrice razlicit od broja vrsta, jer je matrica invertibilna akko je punog ranga. output$is_singular &lt;- output$rank != dim(mat)[1] Ukoliko matrica nije singularna, ima smisla izracunati joj inverz. Za to koristimo funkciju solve, koja sluzi za resavanje sistema oblika \\(Ax = b\\), dok ako joj se prosledi samo matrica, ona vraca inverz te matrice kao rezultat (za detalje pogledati dokumentaciju ?solve). if (!output$is_singular) { output$inverse &lt;- solve(mat) } Za determinantu, imamo funkciju det… output$determinant &lt;- det(mat) Sopstvene vrednosti racunamo funkcijom eigen, koja kao rezultat vraca listu, ciji je jedan od elemenata $values – vektor sopstvenih vrednosti. output$eigenvalues &lt;- eigen(mat)$values Simetricnost matrice proveravamo tako sto posmatramo da li je jednaka svom transponatu. output$is_symmetric &lt;- all(mat == t(mat)) Za odredjivanje da li je matrica dijagonalna, implementiracemo u nastavku sopstvenu funkciju, za sad cemo samo dodati u listu svojstava njenu vrednost. output$is_diagonal &lt;- is_diagonal2(mat) Na kraju zatvaramo if i vracamo konstruisanu izlaznu listu. # ... } return(output) } 2.2 Provera dijagonalnosti Radi provere dijagonalnosti, dacemo dve razlicite implementacije, pa cemo ih uporediti sa stanovista brzine i odabrti najbolju za nasu funkciju. 2.2.1 Implementacija 1 Prva implementacija se zasniva na jednostavnom prolazenju kroz matricu i ukoliko nadjemo element van dijagonale koji nije nula, vratimo FALSE. is_diagonal &lt;- function(mat) { # Ukoliko argument mat nije matrica, javljamo gresku if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } # Prolazimo kroz sve redove... for (i in 1:nrow(mat)) { # ...i sve kolone for (j in 1:ncol(mat)) { # ako smo van dijagonale, i matrica na tom mestu nije nula, # zakljucujemo da matrica nije dijagonalna, i vracamo FALSE if (i != j &amp;&amp; mat[i,j] != 0) return(FALSE) } } # U opstem slucaju vracamo TRUE return(TRUE) } 2.2.2 Implementacija 2 Druga implementacija se oslanja na to da, kada dijagonalnu matricu element po element pomnozimo sa jedinicnom, na kraju opet dobijamo istu tu matricu. Par primera: A &lt;- matrix(1:4, ncol = 2) B &lt;- diag(c(3, 8)) E &lt;- diag(2) A ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 B ## [,1] [,2] ## [1,] 3 0 ## [2,] 0 8 E ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 A * E # nedijagonalna ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 4 B * E # dijagonalna ## [,1] [,2] ## [1,] 3 0 ## [2,] 0 8 To svojstvo mozemo lako implementirati… is_diagonal2 &lt;- function(mat) { if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } # Proverimo da li su svi elementi matrice mat, pomnozene identickom # matricom, jednaki originalnoj matrici mat. Pogledati dokumentaciju # funkcije diag (?diag) all(mat * diag(nrow(mat)) == mat) } 2.2.3 Poredjenje brzine implementacija Za poredjenje brzine implementacija koristicemo biblioteku microbenchmark. # install.packages(&quot;microbenchmark&quot;) library(microbenchmark) Uporedicemo brzinu funkcija is_diagonal i is_diagonal2 za 2 razlicite matrice, jednu dijagonalnu i jednu ne-dijagonalnu. diag_matrix &lt;- diag(300) # 100x100 dijagonalna matrica nondiag_matrix &lt;- matrix(rnorm(9e4), ncol = 300) # random matrica 100x100 Poredjenje za nedijagonalnu: microbenchmark(is_diagonal(nondiag_matrix), is_diagonal2(nondiag_matrix)) ## Unit: microseconds ## expr min lq mean median uq ## is_diagonal(nondiag_matrix) 1.828 2.7735 244.0221 4.2005 6.9105 ## is_diagonal2(nondiag_matrix) 429.683 907.2670 980.6318 920.1245 935.9300 ## max neval ## 23885.70 100 ## 7372.21 100 U ovom slucaju je brza prva implementacija. Pogledajmo i poredjenje za dijagonalnu matricu. microbenchmark(is_diagonal(diag_matrix), is_diagonal2(diag_matrix)) ## Unit: microseconds ## expr min lq mean median uq ## is_diagonal(diag_matrix) 7654.751 7758.851 7911.1131 7890.541 8019.833 ## is_diagonal2(diag_matrix) 539.014 572.920 830.4634 629.289 1062.749 ## max neval ## 8563.536 100 ## 3510.154 100 U ovom slucaju je druga implementacija ubedljivo brza. Ako pogledamo pazljivije, druga implementacija ima u oba slucaja isto vreme, dok se u prvoj implementaciji sa for petljom vremena drasticno razlikuju. Razlog za to je sto u is_diagonal, ako naidjemo na nenula element van dijagonale, odmah izlazimo iz funkcije, a to se desava prilicno brzo, jer vec u drugoj iteraciji petlje dodjemo na neki element van dijagonale. S druge strane, ako imamo dijagonalnu matricu, moramo da prodjemo kroz sve elemente matrice da bismo zakljucili da zaista nisu nule, a to zahteva veliko vreme. Ali avaj! Kada razmislite, druga, brza implementacija uvek mnozi svaki element sa svakim, pa poredi da li su svi elementi neke dve matrice jednaki, sto je mnogo operacija. Zasto je prolazak kroz sve elemente matrice u for petlji bio toliko skup, a u is_diagonal2, gde mnozimo sve elemente matrice (i cak imamo veci broj operacija!) nemamo tu kaznu u vremenu izvrsavanja? Odgovor je u tome sto su mnozenje matrica, poredjenja matrica, i sve operacije nad vektorima i matricama u R-u u pozadini implmentirane u programskom jeziku C ili Fortran-u, koji su kompajlirani jezici i neuporedivo su brzi nego rucno prolazenje kroz petlju u R. Dakle, glavno pravilo kod pisanja brzog koda u R-u je da se oslanjate u sto vecoj meri na ugradjenje funkcije, umesto pravljenja svojih. Takodje, for petlje treba izbegavati u sirokom luku, jer vrlo postoji bolje resenje, a petlje dovode do slabe brzine kode. "]
]
