[
["index.html", "Statistički softver 1 Predgovor Pre nego li počnemo… R / Rstudio Github", " Statistički softver 1 Blagoje Ivanović Poslednja izmena: 25 October, 2019 Predgovor Na ovoj stranici će se nalaziti materijali za statistički softver 1. Cilj kursa je da se upoznamo sa osnovnim, ali i naprednijim konceptima programiranja u jeziku R. Takodje, insistiraćemo na praćenju dobrih praksi u kodiranju i kroz kurs ćemo se upoznati sa nekim često korišćenim alatima u programerskoj zajednici. Kurs će biti praktično orijentisan i ovaj dokument će ličiti na zbirku zadataka iz R-a, gde ćemo implementirati razne funkcije i kroz praksu se suočiti sa problemima. Na ovoj stranici je zapisan okvirni plan kursa (koji će se verovatno menjati usput), u malo lepšem formatu. Korisna literatura Klasičnija literatura koja je od koristi kao uvodni materijal je knjiga R for Dummies. Tu su metodično opisane mogučnosti R-a i česte radnje u njemu. Za one koji bi da nauče dosta više o R-u, obavezna literatura je Advanced R. Takodje, koristićemo i meni posebno dragu knjigu R Inferno, u kojoj su izlistani česti problemi koji se javljaju u radu sa R-om, a vrlo ih je lako prevideti. Pre nego li počnemo… R / Rstudio Pre praćenja materijala, naravano, potrebno je instalirati R i Rstudio, što je opisano na ovim linkovima: uwaterloo.ca i rstudio-education.github.io. Github Takodje, seminarski će se predavati putem Github platforme, koja je najveća platforma koju programeri koriste za deljenje svog koda, kao deo “open source” zajednice. Stoga je za potrebe kursa neophodno da svi naprave nalog na Github.com. "],
["01-uvod.html", "1 Početni koraci 1.1 Primitivni tipovi 1.2 Vektori 1.3 Matrice", " 1 Početni koraci U ovom poglavlju proći ćemo kroz osnovne strukture podataka u R-u. Pored ovoga, dobar pregled nekih osnovnih stvari koje se mogu raditi u R-u se može videti u materijalima koleginice Tamare Milić. 1.1 Primitivni tipovi 1.1.1 Logicki tip - logical (true/false) 1 == 1 ## [1] TRUE 2 == 3 ## [1] FALSE Pisu se velikim slovima, 2 vrednosti - TRUE, FALSE False # ne postoji objekat FALSE Kao uvek, 0 je FALSE 0 == FALSE # TRUE ## [1] TRUE Postoje operatori kao u drugim jezicima !, &amp;&amp;, || !(FALSE || TRUE) &amp;&amp; FALSE ## [1] FALSE 1.1.2 Brojevi - numeric (interno uvek double) 5 + 6 ## [1] 11 3 / 2 # = 1.5, tj. brojevi su po default-u double, pa nema problema ## [1] 1.5 sa celobrojnim deljenjem class(5) ## [1] &quot;numeric&quot; 1.1.3 Celi brojevi - integer (interno int (mozda long)): 5L ## [1] 5 class(5L) ## [1] &quot;integer&quot; 5L / 3L # deljenje opet gleda kao realno, mora se precizirati da ## [1] 1.666667 zelimo celobrojno deljenje operator celobrojnog deljenja je 5 %/% 3 ## [1] 1 mozemo i da promenimo klasu broja u integer as.integer(5 / 3) ## [1] 1 Operacije nad brojevima koje su moguce su: +, -, *, /, %/%, %%, ^ 4 %% 5 # ostatak pri deljenju ## [1] 4 4 ^ 5 # stepenovanje ## [1] 1024 sve je slicno matlabu postoje ugradjene funkcije exp, sin, cos, tan, atan, asin, itd. sin(log(exp(pi))) ## [1] 1.224647e-16 rezultat ovoga nije bas nula, vec 1.22e-16 = 1.22 * 10^(-16) standardna prica sa poredjenjem double/float vrednosti stoji sin(log(exp(pi))) == 0 # FALSE ## [1] FALSE abs(sin(log(exp(pi)))) &lt; 1e-10 # TRUE, za neku toleranciju ## [1] TRUE 1.1.4 Stringovi - character (ne postoji razlika izmedju stringa i karaktera, sve su stringovi) class(&quot;softveri&quot;) ## [1] &quot;character&quot; 1.1.4.1 Neke korisne funkcije za stringove spajanje: paste(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a b&quot; paste0(&quot;a&quot;, &quot;b&quot;) # spaja bez razmaka ## [1] &quot;ab&quot; paste(&quot;Ja&quot;, &quot;matf&quot;, sep = &quot; &lt;3 &quot;) # sep oznacava separator ## [1] &quot;Ja &lt;3 matf&quot; paste(1, 2, 3, sep = &quot; &lt; &quot;) # ako stavimo npr broj, pretvorice se u string ## [1] &quot;1 &lt; 2 &lt; 3&quot; c stil formatiranja sprintf(&quot;Broj %d. Izvucen je broj %d.&quot;, 7, 8) ## [1] &quot;Broj 7. Izvucen je broj 8.&quot; sprintf(&quot;Broj %.2f.&quot;, pi) # pi postoji kao konstanta, e ne postoji vec exp(1) ## [1] &quot;Broj 3.14.&quot; 1.1.4.2 glue - korisna biblioteka za rad sa stringovima stringova # install.packages(&quot;glue&quot;) # ovako se instaliraju paketi. library(glue) # ovako se ucitavaju paketi glue(&quot;{who} &lt;3 {what}&quot;, who = &quot;Ja&quot;, what = &quot;fon&quot;) ## Ja &lt;3 fon glue(&quot;{number} == {number}&quot;, number = 17) ## 17 == 17 istrazite sami paket, premocan je 1.2 Vektori vektori se prave sa funkcijom c (c = combine) c(1, 2, 3) ## [1] 1 2 3 precica za vektore ovog tipa: 1:3 ## [1] 1 2 3 c(1, 3, 45, 65) ## [1] 1 3 45 65 sve operacije nad brojevima mogu se primeniti i na vektore i primenjuju se element po element. Ako znate matlab, razlika je sto su u R sve operacije nad vektorima rade element po element, a za matricno mnozenje i slicno se koriste posebni operatori. Znaci a * b u R je isto kao a .* b u MATLAB c(1, 2) + c(3, 4) ## [1] 4 6 a &lt;- 1:10 # operator dodele je &lt;- b &lt;- 11:20 a * b ## [1] 11 24 39 56 75 96 119 144 171 200 a + b ## [1] 12 14 16 18 20 22 24 26 28 30 a ^ b ## [1] 1.000000e+00 4.096000e+03 1.594323e+06 2.684355e+08 3.051758e+10 ## [6] 2.821110e+12 2.326305e+14 1.801440e+16 1.350852e+18 1.000000e+20 Nad vektorima postoje razne funkcije poput sum, mean, var, sd, median, itd., a i sve elementarne funkcije koje postoje nad brojevima su vektorizovane za vektore, pa je npr. sin(c(1, 2)) = c(sin(1), sin(2)) sin(a) ## [1] 0.8414710 0.9092974 0.1411200 -0.7568025 -0.9589243 -0.2794155 ## [7] 0.6569866 0.9893582 0.4121185 -0.5440211 vektori mogu sadrzati elemente samo jednog primitivnog tipa c(1, 2) ## [1] 1 2 c(1L, 2L) ## [1] 1 2 c(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a&quot; &quot;b&quot; c(&quot;a&quot;, 2) ## [1] &quot;a&quot; &quot;2&quot; c(TRUE, FALSE) ## [1] TRUE FALSE Ukoliko se tipovi ne slazu, pretvorice se u najfleksibilniji tip, znaci logical -&gt; integer -&gt; numeric -&gt; character class(c(TRUE, 1L, 1, &quot;1&quot;)) ## [1] &quot;character&quot; I logicki operatori su vektorizovani, pa je 1:5 &lt;= c(1, 1, 2, 2, 5) # TRUE FALSE FALSE FALSE TRUE ## [1] TRUE FALSE FALSE FALSE TRUE postoje funkcije any, all kao u MATLAB-u any(rep(2, 3) &lt; 1:3) ## [1] TRUE all(rep(2, 3) &lt; 1:3) ## [1] FALSE Kad su logicki vektori u pitanju obratiti paznju na &amp; i &amp;&amp;, kao i | i || R INFERNO and and andand A &lt;- c(FALSE, TRUE, TRUE, FALSE) B &lt;- c(TRUE, FALSE, TRUE, FALSE) &amp; i | rade vektorski - element po element i vracaju vektor! A &amp; B ## [1] FALSE FALSE TRUE FALSE A | B ## [1] TRUE TRUE TRUE FALSE &amp;&amp; i || porede samo prve elemente A &amp;&amp; B ## [1] FALSE A || B ## [1] TRUE 1.3 Matrice matrice se prave funckijom matrix matrix(1:9, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 prvi argument oznacava elemente koje ce sadrzati, to je jedan vektor, pri cemu se u matricu upisuju po kolonama, ukoliko nije specificirano drugacije. nrow argument (ili ncol) specifikuju koliko vrsta ima matrica. matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 za lepsi zapis moze se koristiti byrow = TRUE i pisati ovako matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), byrow = TRUE, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 2 2 2 ## [3,] 3 3 3 Sve elementarne funkcije nad matricama rade kao nad vektorima, znaci vracaju matricu, a primenjuju funkciju na svaki element. Mnozenje matrica se radi operatorom %*%, transponovanje funkcijom t() A &lt;- matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), byrow = TRUE, nrow = 3) t(A) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 A %*% A ## [,1] [,2] [,3] ## [1,] 6 6 6 ## [2,] 12 12 12 ## [3,] 18 18 18 Skalarno mnozenje se moze implementirati na vise nacina, npr u &lt;- c(1, 2, 3) v &lt;- c(4, 5, 6) sum(u * v) ## [1] 32 ili mnozenjem uTv t(u) %*% v ## [,1] ## [1,] 32 Primetimo da poslednji izraz vraca 1x1 matricu, a prvi vraca broj, tj vektor velicine 1. Sa as.numeric mozemo to srediti. as.numeric(t(u) %*% v) ## [1] 32 Vektori kad se tumace kao matrice su naravno kolone vektori. "]
]
