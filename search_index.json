[
["index.html", "Statistički softver 1 Predgovor Pre nego li počnemo… R / Rstudio Github", " Statistički softver 1 Blagoje Ivanović Poslednja izmena: 03 December, 2019 Predgovor Na ovoj stranici će se nalaziti materijali za statistički softver 1. Cilj kursa je da se upoznamo sa osnovnim, ali i naprednijim konceptima programiranja u jeziku R. Takodje, insistiraćemo na praćenju dobrih praksi u kodiranju i kroz kurs ćemo se upoznati sa nekim često korišćenim alatima u programerskoj zajednici. Kurs će biti praktično orijentisan i ovaj dokument će ličiti na zbirku zadataka iz R-a, gde ćemo implementirati razne funkcije i kroz praksu se suočiti sa čestim problemima u R programiranju i videti kako se rešavaju. Na ovoj stranici je zapisan okvirni plan kursa (koji će se verovatno menjati usput), u malo lepšem formatu. Korisna literatura Klasičnija literatura koja je od koristi kao uvodni materijal je knjiga R for Dummies. Tu su metodično opisane mogučnosti R-a i česte radnje u njemu. Za one koji bi da nauče dosta više o R-u, obavezna literatura je Advanced R. Takodje, koristićemo i meni posebno dragu knjigu R Inferno, u kojoj su izlistani česti problemi koji se javljaju u radu sa R-om, a vrlo ih je lako prevideti. Pre nego li počnemo… R / Rstudio Pre praćenja materijala, naravano, potrebno je instalirati R i Rstudio, što je opisano na ovim linkovima: uwaterloo.ca i rstudio-education.github.io. Github Takodje, seminarski će se predavati putem Github platforme, koja je najveća platforma koju programeri koriste za deljenje svog koda, kao deo “open source” zajednice. Stoga je za potrebe kursa neophodno da svi naprave nalog na Github.com. "],
["01-uvod.html", "1 Početni koraci 1.1 Primitivni tipovi 1.2 Vektori 1.3 Matrice 1.4 Liste 1.5 Dataframe", " 1 Početni koraci U ovom poglavlju proći ćemo kroz osnovne strukture podataka u R-u. Pored ovoga, dobar pregled nekih osnovnih stvari koje se mogu raditi u R-u se može videti u materijalima koleginice Tamare Milić. 1.1 Primitivni tipovi 1.1.1 Logicki tip - logical (true/false) 1 == 1 ## [1] TRUE 2 == 3 ## [1] FALSE Pisu se velikim slovima, 2 vrednosti - TRUE, FALSE False # ne postoji objekat FALSE Kao uvek, 0 je FALSE 0 == FALSE # TRUE ## [1] TRUE Postoje operatori kao u drugim jezicima !, &amp;&amp;, || !(FALSE || TRUE) &amp;&amp; FALSE ## [1] FALSE 1.1.2 Brojevi - numeric (interno uvek double) 5 + 6 ## [1] 11 3 / 2 # = 1.5, tj. brojevi su po default-u double, pa nema problema ## [1] 1.5 sa celobrojnim deljenjem class(5) ## [1] &quot;numeric&quot; 1.1.3 Celi brojevi - integer (interno int (mozda long)): 5L ## [1] 5 class(5L) ## [1] &quot;integer&quot; 5L / 3L # deljenje opet gleda kao realno, mora se precizirati da ## [1] 1.666667 zelimo celobrojno deljenje operator celobrojnog deljenja je 5 %/% 3 ## [1] 1 mozemo i da promenimo klasu broja u integer as.integer(5 / 3) ## [1] 1 Operacije nad brojevima koje su moguce su: +, -, *, /, %/%, %%, ^ 4 %% 5 # ostatak pri deljenju ## [1] 4 4 ^ 5 # stepenovanje ## [1] 1024 sve je slicno matlabu postoje ugradjene funkcije exp, sin, cos, tan, atan, asin, itd. sin(log(exp(pi))) ## [1] 1.224647e-16 rezultat ovoga nije bas nula, vec 1.22e-16 = 1.22 * 10^(-16) standardna prica sa poredjenjem double/float vrednosti stoji sin(log(exp(pi))) == 0 # FALSE ## [1] FALSE abs(sin(log(exp(pi)))) &lt; 1e-10 # TRUE, za neku toleranciju ## [1] TRUE 1.1.4 Stringovi - character (ne postoji razlika izmedju stringa i karaktera, sve su stringovi) class(&quot;softveri&quot;) ## [1] &quot;character&quot; 1.1.4.1 Neke korisne funkcije za stringove spajanje: paste(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a b&quot; paste0(&quot;a&quot;, &quot;b&quot;) # spaja bez razmaka ## [1] &quot;ab&quot; paste(&quot;Ja&quot;, &quot;matf&quot;, sep = &quot; &lt;3 &quot;) # sep oznacava separator ## [1] &quot;Ja &lt;3 matf&quot; paste(1, 2, 3, sep = &quot; &lt; &quot;) # ako stavimo npr broj, pretvorice se u string ## [1] &quot;1 &lt; 2 &lt; 3&quot; c stil formatiranja sprintf(&quot;Broj %d. Izvucen je broj %d.&quot;, 7, 8) ## [1] &quot;Broj 7. Izvucen je broj 8.&quot; sprintf(&quot;Broj %.2f.&quot;, pi) # pi postoji kao konstanta, e ne postoji vec exp(1) ## [1] &quot;Broj 3.14.&quot; 1.1.4.2 glue - korisna biblioteka za rad sa stringovima stringova # install.packages(&quot;glue&quot;) # ovako se instaliraju paketi. library(glue) # ovako se ucitavaju paketi glue(&quot;{who} &lt;3 {what}&quot;, who = &quot;Ja&quot;, what = &quot;fon&quot;) ## Ja &lt;3 fon glue(&quot;{number} == {number}&quot;, number = 17) ## 17 == 17 istrazite sami paket, premocan je 1.2 Vektori vektori se prave sa funkcijom c (c = combine) c(1, 2, 3) ## [1] 1 2 3 precica za vektore ovog tipa: 1:3 ## [1] 1 2 3 c(1, 3, 45, 65) ## [1] 1 3 45 65 sve operacije nad brojevima mogu se primeniti i na vektore i primenjuju se element po element. Ako znate matlab, razlika je sto su u R sve operacije nad vektorima rade element po element, a za matricno mnozenje i slicno se koriste posebni operatori. Znaci a * b u R je isto kao a .* b u MATLAB c(1, 2) + c(3, 4) ## [1] 4 6 a &lt;- 1:10 # operator dodele je &lt;- b &lt;- 11:20 a * b ## [1] 11 24 39 56 75 96 119 144 171 200 a + b ## [1] 12 14 16 18 20 22 24 26 28 30 a ^ b ## [1] 1.000000e+00 4.096000e+03 1.594323e+06 2.684355e+08 3.051758e+10 ## [6] 2.821110e+12 2.326305e+14 1.801440e+16 1.350852e+18 1.000000e+20 Nad vektorima postoje razne funkcije poput sum, mean, var, sd, median, itd., a i sve elementarne funkcije koje postoje nad brojevima su vektorizovane za vektore, pa je npr. sin(c(1, 2)) = c(sin(1), sin(2)) sin(a) ## [1] 0.8414710 0.9092974 0.1411200 -0.7568025 -0.9589243 -0.2794155 ## [7] 0.6569866 0.9893582 0.4121185 -0.5440211 vektori mogu sadrzati elemente samo jednog primitivnog tipa c(1, 2) ## [1] 1 2 c(1L, 2L) ## [1] 1 2 c(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a&quot; &quot;b&quot; c(&quot;a&quot;, 2) ## [1] &quot;a&quot; &quot;2&quot; c(TRUE, FALSE) ## [1] TRUE FALSE Ukoliko se tipovi ne slazu, pretvorice se u najfleksibilniji tip, znaci logical -&gt; integer -&gt; numeric -&gt; character class(c(TRUE, 1L, 1, &quot;1&quot;)) ## [1] &quot;character&quot; I logicki operatori su vektorizovani, pa je 1:5 &lt;= c(1, 1, 2, 2, 5) # TRUE FALSE FALSE FALSE TRUE ## [1] TRUE FALSE FALSE FALSE TRUE postoje funkcije any, all kao u MATLAB-u any(rep(2, 3) &lt; 1:3) ## [1] TRUE all(rep(2, 3) &lt; 1:3) ## [1] FALSE Kad su logicki vektori u pitanju obratiti paznju na &amp; i &amp;&amp;, kao i | i || R INFERNO and and andand A &lt;- c(FALSE, TRUE, TRUE, FALSE) B &lt;- c(TRUE, FALSE, TRUE, FALSE) &amp; i | rade vektorski - element po element i vracaju vektor! A &amp; B ## [1] FALSE FALSE TRUE FALSE A | B ## [1] TRUE TRUE TRUE FALSE &amp;&amp; i || porede samo prve elemente A &amp;&amp; B ## [1] FALSE A || B ## [1] TRUE 1.3 Matrice matrice se prave funckijom matrix matrix(1:9, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 prvi argument oznacava elemente koje ce sadrzati, to je jedan vektor, pri cemu se u matricu upisuju po kolonama, ukoliko nije specificirano drugacije. nrow argument (ili ncol) specifikuju koliko vrsta ima matrica. matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 za lepsi zapis moze se koristiti byrow = TRUE i pisati ovako matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), byrow = TRUE, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 2 2 2 ## [3,] 3 3 3 Sve elementarne funkcije nad matricama rade kao nad vektorima, znaci vracaju matricu, a primenjuju funkciju na svaki element. Mnozenje matrica se radi operatorom %*%, transponovanje funkcijom t() A &lt;- matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), byrow = TRUE, nrow = 3) t(A) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 A %*% A ## [,1] [,2] [,3] ## [1,] 6 6 6 ## [2,] 12 12 12 ## [3,] 18 18 18 Skalarno mnozenje se moze implementirati na vise nacina, npr u &lt;- c(1, 2, 3) v &lt;- c(4, 5, 6) sum(u * v) ## [1] 32 ili mnozenjem uTv t(u) %*% v ## [,1] ## [1,] 32 Primetimo da poslednji izraz vraca 1x1 matricu, a prvi vraca broj, tj vektor velicine 1. Sa as.numeric mozemo to srediti. as.numeric(t(u) %*% v) ## [1] 32 Vektori kad se tumace kao matrice su naravno kolone vektori. 1.4 Liste Liste su nizovi koji mogu da sadrze objekte razlicitih tipova. Prakticno mogu da sadrze kao svoje elemente bilo koji objekat u R-u: vektore, matrice, druge liste, itd. n &lt;- c(2, 3, 5) s &lt;- c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;, &quot;ee&quot;) b &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) lst &lt;- list(n, s, b) # lst sadrzi kopije od n, s, b lst[1] #niz n ## [[1]] ## [1] 2 3 5 lst[2] #niz s ## [[1]] ## [1] &quot;aa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot; &quot;ee&quot; Na ovaj način dobijamo kopije prvog, odnosno drugog člana liste Međutim ako hoćemo da direktno pristupimo članu liste koristimo [[ ]] lst[[1]] ## [1] 2 3 5 Tada možemo da menjamo sadržaj liste lst[[2]]&lt;-c(&quot;a&quot;,&quot;b&quot;) lst[[2]][1]&lt;-&quot;c&quot; Liste mogu imati i imena clanova, kojima se onda moze pristupati dolarima $. named_list &lt;- list(brojevi = 1:5, slova = c(&quot;a&quot;, &quot;b&quot;)) named_list$brojevi ## [1] 1 2 3 4 5 named_list[[1]] ## [1] 1 2 3 4 5 1.5 Dataframe Dataframe je najčešći način čuvanja podataka u R-u i vrlo je pogodan za rad i analizu. Služi za prikaz tabelarnih podataka, pa liči na matricu, s tim što je dataframe u snovi lista koja sadrži vektore jednakih dužina (kolone), pri čemu ti vektori ne moraju biti istog tipa. Dakle možemo imati jednu kolonu koju čine brojevi, a drugu tekstualni podaci. Dataframe se pravi na sledeći način: df &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;)) df ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci Ovako smo dobili dataframe sa dve kolone, od kojih je jedna numerička a druga tekstualna. str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ kolona1: num 1 2 3 ## $ kolona2: Factor w/ 3 levels &quot;drugi&quot;,&quot;prvi&quot;,..: 2 1 3 R podrazumevano pretvara tekstualne podatke u faktore, to možemo preduprediti ako dodamo argument stringsAsFactors = FALSE. df &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ kolona1: num 1 2 3 ## $ kolona2: chr &quot;prvi&quot; &quot;drugi&quot; &quot;treci&quot; df ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci Dva dataframe-a (koji imaju isi broj kolona) se mogu spojiti da dobijemo više kolona korišćenjem funkcije cbind. df1 &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) df2 &lt;- data.frame(kolona3 = c(4,5,6), kolona4 = c(&quot;prvi1&quot;, &quot;drugi1&quot;, &quot;treci1&quot;), stringsAsFactors = FALSE) df3 &lt;- cbind(df1, df2) df3 ## kolona1 kolona2 kolona3 kolona4 ## 1 1 prvi 4 prvi1 ## 2 2 drugi 5 drugi1 ## 3 3 treci 6 treci1 Takodje, mogu se nadovezati po vrstama (ako imaju ista imena kolona) funkcijom rbind. df1 &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) df2 &lt;- data.frame(kolona1 = c(4,5,6), kolona2 = c(&quot;prvi1&quot;, &quot;drugi1&quot;, &quot;treci1&quot;), stringsAsFactors = FALSE) df4 &lt;- rbind(df1, df2) df4 ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci ## 4 4 prvi1 ## 5 5 drugi1 ## 6 6 treci1 Vrednostima kolona možemo pristupati pomoću operatora $, kao u listama, a istim možemo i dodati nove kolone. df$kolona1 ## [1] 1 2 3 df$kolona5 &lt;- c(7,8,9) df ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 2 2 drugi 8 ## 3 3 treci 9 Medjutim, možda elegantniji način filtriranja i odabira podskupova dataframe-a je korišćenjem uglatih zagrada. Koristimo notaciju df[redovi, kolone], gde prvim argumentom odredjujemo koje redove želimo da uzmemo, a drugim koje kolone. Prazno mesto za neki od argumenata znači “uzmi sve”. df[,] # sve ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 2 2 drugi 8 ## 3 3 treci 9 df[1,] # prva vrsta ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 df[,1] # prva kolona ## [1] 1 2 3 Redovi mogu biti ili vektori brojeva koji označavaju indekse redova koje da uzmemo, ili vektori TRUE/FALSE vrednosti iste dužine kao broj vrsta u dataframe-u, pri čemu se tada biraju redovi na pozicijama gde je u vektoru vrednost TRUE. df4[c(1,3,4), ] # sve kolone, redovi 1,3,4 ## kolona1 kolona2 ## 1 1 prvi ## 3 3 treci ## 4 4 prvi1 df4[df4$kolona1 &gt; 3, ] # sve kolone, one vrste kod kojih je kolona1 veca od 3 ## kolona1 kolona2 ## 4 4 prvi1 ## 5 5 drugi1 ## 6 6 treci1 Kolone mogu biti ili vektori brojeva koji označavaju koje kolone da uzmemo prema indeksu, ili vektori stringova, koji označavaju imena kolona koje da uzmemo. df3[, c(1,3)] # sve vrste, 1 i 3 kolona ## kolona1 kolona3 ## 1 1 4 ## 2 2 5 ## 3 3 6 df3[, c(&quot;kolona1&quot;, &quot;kolona3&quot;)] # isto ## kolona1 kolona3 ## 1 1 4 ## 2 2 5 ## 3 3 6 df3[c(1,3), c(&quot;kolona1&quot;, &quot;kolona3&quot;)] # prvi i treci red, prva i treca kolona ## kolona1 kolona3 ## 1 1 4 ## 3 3 6 Korisna stvar je da ako koristimo vektore brojeva za indeksiranje, ukoliko stavimo znak - ispred, to znači da izuzimamo te redove/kolone. df[, -1] # sve bez prve kolone ## kolona2 kolona5 ## 1 prvi 7 ## 2 drugi 8 ## 3 treci 9 df[-2, ] # sve bez druge vrste ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 3 3 treci 9 df[-c(1,2), c(&quot;kolona2&quot;, &quot;kolona5&quot;)] # druga i peta kolona, bez prve i druge vrste ## kolona2 kolona5 ## 3 treci 9 Konačno, za osnovne informacije o tabeli postoje funkcije colnames, rownames, ncol i nrow, za koje možete pretpostaviti šta rade. "],
["02-generisanje.html", "2 Generisanje slucajnih velicina 2.1 Primeri sa teorije verovatnoca 2.2 Metoda inverzne transformacije", " 2 Generisanje slucajnih velicina 2.1 Primeri sa teorije verovatnoca Pokazacemo kako se mogu generisati uzorci iz raspodela koje smo radili na Teoriji verovatnoca. 2.1.1 Prvi zadatak \\(X\\sim \\mathcal{U}(0,1)\\). Odrediti raspodelu: \\(Y = aX+b\\) \\(W = -\\log X\\) 2.1.1.1 Raspodela \\(Y = aX+b\\) Od ranije (sa TV-a), znamo da treba da bude \\(Y\\sim\\mathcal{U}(b, a+b)\\). # runif sluzi za generisanje slucajnih brojeva iz uniformne (0,1) raspodele x &lt;- runif(1e4) # nacrtamo histogram hist(x) # generisemo y po definiciji, uzimamo npr. a = 3, b = 7 y &lt;- 3 * x + 7 hist(y) Histogrami za x i y izgledaju slicno, kao uniformna raspodela (svi stupci su iste visine), ali nosac za y je od 7 do 10, sto je bas sto smo ocekivali. 2.1.1.2 Raspodela \\(W=-\\log X\\) Treba da bude \\(W\\sim\\mathcal{E}(1)\\). hist(x) # transformisemo x u w logaritmom w &lt;- -log(x) # crtamo histogram, probability argument obezbedjuje da na y osi budu # frekvencije umesto broj pojavljivanja. # Slika je ista, ali y osa je sad na (0,1) hist(w, probability = TRUE) # crtamo funkciju dexp - gustinu eksponencijalne raspodele # funkcija curve crta datu krivu # curve uvek prima izraz po x # xlim odredjujegranice x ose na grafiku # add = TRUE znaci da se doda na prethodni grafik curve(dexp(x), xlim = c(0, 5), add = TRUE, col = &quot;red&quot;) Vidimo da se dobro poklapaju histogram i teoretska gustina eksponencijalne raspodele. 2.1.2 Drugi zadatak \\(X \\sim \\mathcal{E}(\\lambda)\\). Odrediti raspodele: \\(Y = [X]\\) \\(W = 1-e^{-\\lambda X}\\) 2.1.2.1 Raspodela \\(Y\\) Treba da bude \\(Y \\sim\\mathcal{G}(1-e^{-\\lambda})\\) # sa rexp generisemo uzorak iz eksponencijalne raspodele x &lt;- rexp(1e4, rate = 0.1) #lambda = 0.1 hist(x, prob = TRUE) y &lt;- floor(x) # ceo deo je floor funkcija # crtamo histogram y hist(y, prob = TRUE) # sad cemo da nacrtamo preko histograma odgovarajuce vrednosti sa zakona # raspodele geometrijske raspodele, posto nemamo gustinu # uzecemo tacke od 1 do 50, jer geometrijska raspodela uzima vrednosti 1,2,... # (ogranicili smo se na 50 bez posebnog razloga, dovoljno je veliki broj) pts &lt;- seq_len(50) # i nacrtacemo vrednost zakona raspodele, koji se dobija funkcijom dgeom, # koristecu funkciju points, koja na postojeci grafik dodaje tacke. points(dgeom(pts, prob = 1-exp(-0.1)), col = &quot;red&quot;) 2.2 Metoda inverzne transformacije 2.2.1 Uvodni primeri Na Teoriji verovatnoca samo pokazali da ako je \\(X\\) slucajna velicina sa funkcijom raspodele \\(F_X\\), onda \\(Y=F_X(X)\\) ima uniformnu raspodelu na \\([0,1]\\) Slicno, ako je \\(U\\sim \\mathcal{U}[0,1]\\), onda \\(T=F_X^{-1}(U)\\) ima istu raspodelu kao \\(X\\). Pogledajmo neke primere u &lt;- runif(1e4) hist(u) Kada na u primenimo qnorm (inverz funkcije raspodele normalne raspodele), treba da dobijemo normalnu raspodelu. y &lt;- qnorm(u) hist(y) Ako zelimo da dobijemo normalnu raspodelu \\(\\mathcal{N}(2, 5)\\), to mozemo uraditi na vise nacina. Jedan je da transformisemo standardnu normalnu raspodelu linearnom transformacijom \\(\\sigma X + m\\), a drugi da prosto damo argumente mean i sd funkciji qnorm. y &lt;- qnorm(u) hist(sqrt(5)*y + 2) y &lt;- qnorm(u, mean = 2, sd = sqrt(5)) hist(y) Ako hocemo uzorak iz eksponencijalne raspodele, samo na u primenimo qexp sto predstavlja inver funkcije raspodele eksponencijalne raspodele. hist(qexp(u, rate = pi)) 2.2.2 Opsti generator Napravicemo sada opsti generator slucajnih brojeva iz apsolutno neprekidnih raspodela, trazenjem inverza funkcije raspodele numerickim metodama. Ovaj generator cemo moci da koristimo za generisanje uzoraka iz proizvoljne apsolutno neprekidne raspodele. Numericko trazenje inverza se zasniva na sledecem: Ako je \\(x = F^{-1}(t)\\), to znaci da je \\(t = F(x)\\), tj. \\(x\\) je resenje jednacine \\(F(x) - t = 0\\), tj. \\(x\\) je nula funkcije \\(g(x) = F(x) - t\\). Dakle, da bismo nasli numericki inverz neke funkcije \\(F\\), potrebno je da nadjemo nulu funkcije \\(g(x) = F(x) - t\\). Napravicemo prvo funkciju koja za datu funkciju i tacku \\(t\\) vraca inverz te funkcije u toj tacki. # Funkcija koja vraca inverz funkcije f u tacki t. # Domen funkcije f je argument support. # Primer: # f &lt;- pexp # inv(f, 0.3, c(0, 100000)) inv &lt;- function(f, t, support) { uniroot(function(x) f(x) - t, interval = support)$root } Testirajmo vrednost koju vraca. inv(pexp...)(pexp je funkcija raspodele) treba da se poklopi sa qexp. inv(pexp, 0.3, c(0, 1000)) ## [1] 0.3566753 qexp(0.3) ## [1] 0.3566749 Napravimo sada fuknciju koja ce da se koristi kao generator. # Kao argument funkcije primamo obim uzorka koji generisemo, # funkciju raspodele trazene raspodele i nosac raspodele. generator &lt;- function(n, cdf, support) { # inicijalizujemo uzorak kao prazan vektor od n elemenata sample &lt;- numeric(n) # generisemo n brojeva iz uniformne raspodele u &lt;- runif(n) # za svaki od brojeva u_i primenimo inverz funkcije raspodele for (i in 1:n) { sample[i] &lt;- inv(cdf, u[i], support) } # vracamo uzorak return(sample) } Testirajmo da li generator pravi dobar uzorak, na primeru normalne raspodele: x &lt;- generator(1000, pnorm, c(-1000, 1000)) hist(x) 2.2.2.1 Zadatak. Generisati uzorak obima 100 iz raspodele sa funkcijom raspodele \\(F(x) = \\begin{cases} 0,&amp; u &lt; 0 \\\\ 1 - e^{-\\lambda\\sqrt{u}},&amp; u \\geq0 \\end{cases}\\) lambda &lt;- 2 cdf &lt;- function(x) 1 - exp(-lambda*sqrt(x)) hist(generator(100, cdf, support = c(0, 10000))) "],
["03-matsum.html", "3 Matrix summary 3.1 Implementacija funkcije matrix_summary 3.2 Provera dijagonalnosti 3.3 Funkcija print_matrix_summary 3.4 Celokupni kod", " 3 Matrix summary Napravicemo funkciju ciji cilj je da odredi osnovna svojstva matrice, poput dimenzije, ranga, sopstvenih vrednosti, invertibilnosti, dijagonalnosti i slicno. Nakon toga napravicemo i funkciju koja stampa sazetak osnovnih svojstava matrice u lepom formatu, sa glue bibliotekom. Pisacemo red po red funkcije, uz detaljna objasnjenja, pa na kraju dati kompletan kod. 3.1 Implementacija funkcije matrix_summary Definisimo prvo funkciju, primace argument mat koji predstavlja matricu matrix_summary &lt;- function(mat) { # ... Izlaz ce nam biti lista koja sadrzi trazena svojstva matrice. Biramo listu kao izlazni tip, jer zelimo da skladistimo objekte raznih dimenzija i tipova, pa se ne mozemo zadovoljiti vektorskim tipom. Dakle, kreiramo praznu listu, koju cemo dalje popunjavati. output &lt;- list() Za pocetak dodacemo u listu izlaza matricu koju analiziramo, kao i dimenzije output$matrix &lt;- mat output$dimensions &lt;- dim(mat) Sledeci je rang matrice. Njega cemo racunati pomocu funkcije rankMatrix iz Matrix paketa library(Matrix) output$rank &lt;- rankMatrix(mat) Da li je matrica kvadratna cemo proveriti uporedjivanjem dimenzija matrice. Ukoliko je razlika broja kolona i vrsta jednaka 0, to znaci da je matrica kvadratna. output$is_square &lt;- diff(dim(mat)) == 0 Dalja svojstva matrice koja cemo gledati su: kvadratnost, inveritbilnost, inverz, sopstvene vrednosti, simetricnost i dijagonalnosti. Ova svojstva imaju smisla samo za kvadratne matrice, pa ce to biti uslov da razmatramo ova svojstva. if (output$is_square) { # ... Da li je matrica singularna (tj. nema inverz) proveravamo tako sto pogledamo da li je rang matrice razlicit od broja vrsta, jer je matrica invertibilna akko je punog ranga. output$is_singular &lt;- output$rank != dim(mat)[1] Ukoliko matrica nije singularna, ima smisla izracunati joj inverz. Za to koristimo funkciju solve, koja sluzi za resavanje sistema oblika \\(Ax = b\\), dok ako joj se prosledi samo matrica, ona vraca inverz te matrice kao rezultat (za detalje pogledati dokumentaciju ?solve). if (!output$is_singular) { output$inverse &lt;- solve(mat) } Za determinantu, imamo funkciju det… output$determinant &lt;- det(mat) Sopstvene vrednosti racunamo funkcijom eigen, koja kao rezultat vraca listu, ciji je jedan od elemenata $values – vektor sopstvenih vrednosti. output$eigenvalues &lt;- eigen(mat)$values Simetricnost matrice proveravamo tako sto posmatramo da li je jednaka svom transponatu. output$is_symmetric &lt;- all(mat == t(mat)) Za odredjivanje da li je matrica dijagonalna, implementiracemo u nastavku sopstvenu funkciju, za sad cemo samo dodati u listu svojstava njenu vrednost. output$is_diagonal &lt;- is_diagonal2(mat) Na kraju zatvaramo if i vracamo konstruisanu izlaznu listu. # ... } return(output) } 3.2 Provera dijagonalnosti Radi provere dijagonalnosti, dacemo dve razlicite implementacije, pa cemo ih uporediti sa stanovista brzine i odabrti najbolju za nasu funkciju. 3.2.1 Implementacija 1 Prva implementacija se zasniva na jednostavnom prolazenju kroz matricu i ukoliko nadjemo element van dijagonale koji nije nula, vratimo FALSE. is_diagonal &lt;- function(mat) { # Ukoliko argument mat nije matrica, javljamo gresku if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } # Prolazimo kroz sve redove... for (i in 1:nrow(mat)) { # ...i sve kolone for (j in 1:ncol(mat)) { # ako smo van dijagonale, i matrica na tom mestu nije nula, # zakljucujemo da matrica nije dijagonalna, i vracamo FALSE if (i != j &amp;&amp; mat[i,j] != 0) return(FALSE) } } # U opstem slucaju vracamo TRUE return(TRUE) } 3.2.2 Implementacija 2 Druga implementacija se oslanja na to da, kada dijagonalnu matricu element po element pomnozimo sa jedinicnom, na kraju opet dobijamo istu tu matricu. Par primera: A &lt;- matrix(1:4, ncol = 2) B &lt;- diag(c(3, 8)) E &lt;- diag(2) A ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 B ## [,1] [,2] ## [1,] 3 0 ## [2,] 0 8 E ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 A * E # nedijagonalna ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 4 B * E # dijagonalna ## [,1] [,2] ## [1,] 3 0 ## [2,] 0 8 To svojstvo mozemo lako implementirati… is_diagonal2 &lt;- function(mat) { if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } # Proverimo da li su svi elementi matrice mat, pomnozene identickom # matricom, jednaki originalnoj matrici mat. Pogledati dokumentaciju # funkcije diag (?diag) all(mat * diag(nrow(mat)) == mat) } 3.2.3 Poredjenje brzine implementacija Za poredjenje brzine implementacija koristicemo biblioteku microbenchmark. # install.packages(&quot;microbenchmark&quot;) library(microbenchmark) Uporedicemo brzinu funkcija is_diagonal i is_diagonal2 za 2 razlicite matrice, jednu dijagonalnu i jednu ne-dijagonalnu. diag_matrix &lt;- diag(300) # 100x100 dijagonalna matrica nondiag_matrix &lt;- matrix(rnorm(9e4), ncol = 300) # random matrica 100x100 Poredjenje za nedijagonalnu: microbenchmark(is_diagonal(nondiag_matrix), is_diagonal2(nondiag_matrix)) ## Unit: microseconds ## expr min lq mean median uq ## is_diagonal(nondiag_matrix) 1.446 2.18 63.2991 2.8615 5.4900 ## is_diagonal2(nondiag_matrix) 359.928 368.69 619.1401 608.2255 763.4415 ## max neval ## 5925.164 100 ## 3418.727 100 U ovom slucaju je brza prva implementacija. Pogledajmo i poredjenje za dijagonalnu matricu. microbenchmark(is_diagonal(diag_matrix), is_diagonal2(diag_matrix)) ## Unit: microseconds ## expr min lq mean median uq ## is_diagonal(diag_matrix) 6093.314 6201.724 6288.3920 6261.760 6345.8550 ## is_diagonal2(diag_matrix) 607.403 899.374 933.0676 912.993 925.7335 ## max neval ## 6716.388 100 ## 3890.304 100 U ovom slucaju je druga implementacija ubedljivo brza. Ako pogledamo pazljivije, druga implementacija ima u oba slucaja isto vreme, dok se u prvoj implementaciji sa for petljom vremena drasticno razlikuju. Razlog za to je sto u is_diagonal, ako naidjemo na nenula element van dijagonale, odmah izlazimo iz funkcije, a to se desava prilicno brzo, jer vec u drugoj iteraciji petlje dodjemo na neki element van dijagonale. S druge strane, ako imamo dijagonalnu matricu, moramo da prodjemo kroz sve elemente matrice da bismo zakljucili da zaista nisu nule, a to zahteva veliko vreme. Ali avaj! Kada razmislite, druga, brza implementacija uvek mnozi svaki element sa svakim, pa poredi da li su svi elementi neke dve matrice jednaki, sto je mnogo operacija. Zasto je prolazak kroz sve elemente matrice u for petlji bio toliko skup, a u is_diagonal2, gde mnozimo sve elemente matrice (i cak imamo veci broj operacija!) nemamo tu kaznu u vremenu izvrsavanja? Odgovor je u tome sto su mnozenje matrica, poredjenja matrica, i sve operacije nad vektorima i matricama u R-u u pozadini implmentirane u programskom jeziku C ili Fortran-u, koji su kompajlirani jezici i neuporedivo su brzi nego rucno prolazenje kroz petlju u R. Dakle, glavno pravilo kod pisanja brzog koda u R-u je da se oslanjate u sto vecoj meri na ugradjenje funkcije, umesto pravljenja svojih. Takodje, for petlje treba izbegavati u sirokom luku, jer vrlo postoji bolje resenje, a petlje dovode do slabe brzine kode. 3.3 Funkcija print_matrix_summary Sada cemo napisati jednostavnu funkciju koja ce nase zakljucke iz funkcije matrix_summary napisati kao kratak opis matrice. Neki primeri koje bismo ocekivali: “m by n matrix of rank r” “n by n square, symmetric, nonsingular matrix of rank n” “n by n square, singular matrix of rank 7” Definisimo prvo funkciju, primace argument mat koji predstavlja matricu print_matrix_summary &lt;- function(mat) { # ... Ucitacemo biblioteku glue koju cemo koristiti za pravljenje poruke. library(glue) Ucitacemo rezultat matrix_summary funkcije, na osnovu kog cemo praviti sazeti opis matrice. mat_summary &lt;- matrix_summary(mat) Imamo dva glavna slucaja - kvadratne i nekvadratne matrice. Ako matrica nije kvadratna, nemamo neki poseban rezultat, vec samo znamo dimenziju i rang, pa cemo samo to istampati # ako nije kvadratna... if (!mat_summary$is_square) { # ... istampaj... print( # ... poruku koja je oblika &quot;m by n matrix of rank r&quot; # funkcija glue dopusta koriscenje vrednosti promenljivih ako se pisu # unutar zagrada { } i on ce zameniti taj izraz njegovom vrednoscu. glue(&quot;{dim(mat)[1]} by {dim(mat)[2]} matrix of rank {mat_summary$rank}&quot;) ) } Ako je matrica kvadratna, onda imamo nekoliko svojstava koje zelimo da proverimo i da ispisemo. String koji cemo da ispisemo cemo praviti nadovezivanjem svakog svojstva jedno po jedno, pocevsi od praznog stringa. else { # string koji sadrzi svojstva matrice cemo inicijalizovati kao prazan properties &lt;- &quot;&quot; # ako je matrica simetricna, dodacemo string &quot;, symmetric&quot; na string # properties if (mat_summary$is_symmetric) properties &lt;- glue(properties, &quot;, symmetric&quot;) # ako je matrica dijagonalna, dodajemo string &quot;, diagonal&quot; na string # properties (kao rezultat dobijamo &quot;, symmetric, diagonal&quot;) if (mat_summary$is_diagonal) properties &lt;- glue(properties, &quot;, diagonal&quot;) # konacno, dodajemo string &quot;, singular&quot; ako je matrica singularna # (nema inverz) ili string &quot;, nonsingular&quot; ako matrica nije singularna. properties &lt;- glue(properties, ifelse(mat_summary$is_singular, &quot;, singular&quot;, &quot;, nonsingular&quot;)) # properties string sada ima oblik slican ovom: # &quot;, symmetric, diagonal, nonsingular&quot; i ideja je da ga nadovezemo na string # &quot;m by n square&quot;, i na rezultat dodamo &quot; matrix of rank r&quot;, cime bi kao # rezultat dobili string tipa: # &quot;m by n square&quot;+&quot;, symmetric, diagonal, nonsingular&quot;+&quot; matrix of rank r&quot; = # &quot;m by n square, symmetric, diagonal, nonsingular matrix of rank r&quot; print( # funkcija glue po default-u nadovezuje argumente koji su joj prosledjeni. glue( &quot;{dim(mat)[1]} by {dim(mat)[2]} square{properties}&quot;, &quot; matrix of rank {mat_summary$rank}&quot; ) ) } 3.4 Celokupni kod # Returns whether the given matrix is diagonal is_diagonal &lt;- function(mat) { if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } for (i in 1:nrow(mat)) { for (j in 1:ncol(mat)) { if (i != j &amp;&amp; mat[i,j] != 0) return(FALSE) } } return(TRUE) } is_diagonal2 &lt;- function(mat) { if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } all(mat * diag(nrow(mat)) == mat) } # Matrix summary # Inputs: matrix mat # Outputs: Basic properties od the matrix # E.g. Square? Diagonal? Symmetric? Rank, dimensions, # eigenvalues, inverse, Singular?, determinant matrix_summary &lt;- function(mat) { output &lt;- list() output$matrix &lt;- mat output$dimensions &lt;- dim(mat) library(Matrix) output$rank &lt;- rankMatrix(mat) output$is_square &lt;- diff(dim(mat)) == 0 if (output$is_square) { output$is_singular &lt;- !(output$rank == dim(mat)[1]) if (!output$is_singular) { output$inverse &lt;- solve(mat) } output$determinant &lt;- det(mat) output$eigenvalues &lt;- eigen(mat)$values output$is_symmetric &lt;- all(mat == t(mat)) output$is_diagonal &lt;- is_diagonal2(mat) } class(output) &lt;- &quot;matrixSummary&quot; return(output) } # Prints out matrix description # E.g. &quot;m by n matrix of rank r&quot; # &quot;n by n square, symmetric, nonsingular matrix of rank n&quot; # &quot;n by n square, singular matrix of rank 7&quot; print_matrix_summary &lt;- function(mat) { library(glue) mat_summary &lt;- matrix_summary(mat) if (!mat_summary$is_square) { print( glue(&quot;{dim(mat)[1]} by {dim(mat)[2]} matrix of rank {mat_summary$rank}&quot;) ) } else { properties &lt;- &quot;&quot; if (mat_summary$is_symmetric) properties &lt;- glue(properties, &quot;, symmetric&quot;) if (mat_summary$is_diagonal) properties &lt;- glue(properties, &quot;, diagonal&quot;) properties &lt;- glue(properties, ifelse(mat_summary$is_singular, &quot;, singular&quot;, &quot;, nonsingular&quot;)) print( glue( &quot;{dim(mat)[1]} by {dim(mat)[2]} square{properties}&quot;, &quot; matrix of rank {mat_summary$rank}&quot; ) ) } } "],
["04-apply.html", "4 *apply funkcije 4.1 Primer sapply funkcije", " 4 *apply funkcije Upoznacemo se u ovom poglavlju sa *apply familijom funkcija, i to: apply, sapply i lapply funkcijama, koje cine osnovu funkcionalnog programiranja u R-u. U pitanju su funkcije koje sluze za preslikavanje elemenata vektora/matrica/listi u nove vektore/matrice/liste primenom jedne iste funkcije na svaki element. Na primer, najjednostavnija od njih, funkcija sapply se poziva ovako: sapply(v, f), gde je v vektor/lista/matrica, a f funkcija koju treba primeniti na svaki element od v. Dakle dobijamo preslikavanje: \\[v = (v_1, v_2, \\dots, v_n)\\stackrel{sapply}{\\rightarrow} (f(v_1), f(v_2), \\dots, f(v_n)).\\] 4.1 Primer sapply funkcije Kao sto rekosmo, sapply primenjuje datu funkciju na svaki element datog vektora/liste/matrice i vraca rezultujuci vektor. Treba napomenuti da uvek pokusava da kao rezultat vrati vektor, a ukoliko to nije moguce, vraca listu. Kao primer koriscenja sapply vraticemo se na nas generator metodom inverzne transformacije. generator &lt;- function(n, cdf, support) { # inicijalizujemo uzorak kao prazan vektor od n elemenata sample &lt;- numeric(n) # generisemo n brojeva iz uniformne raspodele u &lt;- runif(n) # za svaki od brojeva u_i primenimo inverz funkcije raspodele for (i in 1:n) { sample[i] &lt;- inv(cdf, u[i], support) } # vracamo uzorak return(sample) } Vidimo da je ceo kod u generatoru zasnovan na tome da generisemo \\(n\\) brojeva iz uniformne raspodele, pa na svaki od njih primenimo funkciju function(u) inv(cdf, u, support) (u[i] zamenjeno sa u). Ovo je bas ono sto ocekujemo od sapply funkcije! Stoga promenimo kod generatora da to iskoristi. generator &lt;- function(n, cdf, support) { # generisemo n brojeva iz uniformne raspodele u &lt;- runif(n) # na svaki element iz u primenimo inverznu transformaciju sample &lt;- sapply(u, function(u) inv(cdf, u, support)) return(sample) } To je ceo kod! Sveli smo kod prakticno na 2 reda, jer smo izbacili tehnicke stvari poput inicijalizacije vektora koji vracamo, prolazenja kroz petlju i popunjavanja rezultujuceg vektora clan po clan. Ostao je kod koji sadrzi samo sustinu onoga sto hocemo da uradimo: uzmemo uzorak iz uniformne raspodele (u &lt;- runif(n)) Svaki element uzorka transformisemo inverznom transformacijom (sapply(u, function(u) inv(cdf, u, support))) Nista vise od toga nije trazeno u matematickom zapisu metoda, pa nema potrebe ni da komplikujemo kod. Upravo to je (pored brzine i nekih tehnickih stvari poput bolje otpornosti na greske od petlji) glavna prednost *apply funkcija naspram petlji – kod cine mnogo citljivijim (nakon sto je korisnik upoznat sa ovim funkcijama, naravno). "]
]
