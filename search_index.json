[
["index.html", "Statistički softver 1 Predgovor Pre nego li počnemo… R / Rstudio Github", " Statistički softver 1 Blagoje Ivanović Poslednja izmena: 11 December, 2019 Predgovor Na ovoj stranici će se nalaziti materijali za statistički softver 1. Cilj kursa je da se upoznamo sa osnovnim, ali i naprednijim konceptima programiranja u jeziku R. Takodje, insistiraćemo na praćenju dobrih praksi u kodiranju i kroz kurs ćemo se upoznati sa nekim često korišćenim alatima u programerskoj zajednici. Kurs će biti praktično orijentisan i ovaj dokument će ličiti na zbirku zadataka iz R-a, gde ćemo implementirati razne funkcije i kroz praksu se suočiti sa čestim problemima u R programiranju i videti kako se rešavaju. Na ovoj stranici je zapisan okvirni plan kursa (koji će se verovatno menjati usput), u malo lepšem formatu. Korisna literatura Klasičnija literatura koja je od koristi kao uvodni materijal je knjiga R for Dummies. Tu su metodično opisane mogučnosti R-a i česte radnje u njemu. Za one koji bi da nauče dosta više o R-u, obavezna literatura je Advanced R. Takodje, koristićemo i meni posebno dragu knjigu R Inferno, u kojoj su izlistani česti problemi koji se javljaju u radu sa R-om, a vrlo ih je lako prevideti. Pre nego li počnemo… R / Rstudio Pre praćenja materijala, naravano, potrebno je instalirati R i Rstudio, što je opisano na ovim linkovima: uwaterloo.ca i rstudio-education.github.io. Github Takodje, seminarski će se predavati putem Github platforme, koja je najveća platforma koju programeri koriste za deljenje svog koda, kao deo “open source” zajednice. Stoga je za potrebe kursa neophodno da svi naprave nalog na Github.com. "],
["01-uvod.html", "1 Početni koraci 1.1 Primitivni tipovi 1.2 Vektori 1.3 Matrice 1.4 Liste 1.5 Dataframe", " 1 Početni koraci U ovom poglavlju proći ćemo kroz osnovne strukture podataka u R-u. Pored ovoga, dobar pregled nekih osnovnih stvari koje se mogu raditi u R-u se može videti u materijalima koleginice Tamare Milić. 1.1 Primitivni tipovi 1.1.1 Logicki tip - logical (true/false) 1 == 1 ## [1] TRUE 2 == 3 ## [1] FALSE Pisu se velikim slovima, 2 vrednosti - TRUE, FALSE False # ne postoji objekat FALSE Kao uvek, 0 je FALSE 0 == FALSE # TRUE ## [1] TRUE Postoje operatori kao u drugim jezicima !, &amp;&amp;, || !(FALSE || TRUE) &amp;&amp; FALSE ## [1] FALSE 1.1.2 Brojevi - numeric (interno uvek double) 5 + 6 ## [1] 11 3 / 2 # = 1.5, tj. brojevi su po default-u double, pa nema problema ## [1] 1.5 sa celobrojnim deljenjem class(5) ## [1] &quot;numeric&quot; 1.1.3 Celi brojevi - integer (interno int (mozda long)): 5L ## [1] 5 class(5L) ## [1] &quot;integer&quot; 5L / 3L # deljenje opet gleda kao realno, mora se precizirati da ## [1] 1.666667 zelimo celobrojno deljenje operator celobrojnog deljenja je 5 %/% 3 ## [1] 1 mozemo i da promenimo klasu broja u integer as.integer(5 / 3) ## [1] 1 Operacije nad brojevima koje su moguce su: +, -, *, /, %/%, %%, ^ 4 %% 5 # ostatak pri deljenju ## [1] 4 4 ^ 5 # stepenovanje ## [1] 1024 sve je slicno matlabu postoje ugradjene funkcije exp, sin, cos, tan, atan, asin, itd. sin(log(exp(pi))) ## [1] 1.224647e-16 rezultat ovoga nije bas nula, vec 1.22e-16 = 1.22 * 10^(-16) standardna prica sa poredjenjem double/float vrednosti stoji sin(log(exp(pi))) == 0 # FALSE ## [1] FALSE abs(sin(log(exp(pi)))) &lt; 1e-10 # TRUE, za neku toleranciju ## [1] TRUE 1.1.4 Stringovi - character (ne postoji razlika izmedju stringa i karaktera, sve su stringovi) class(&quot;softveri&quot;) ## [1] &quot;character&quot; 1.1.4.1 Neke korisne funkcije za stringove spajanje: paste(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a b&quot; paste0(&quot;a&quot;, &quot;b&quot;) # spaja bez razmaka ## [1] &quot;ab&quot; paste(&quot;Ja&quot;, &quot;matf&quot;, sep = &quot; &lt;3 &quot;) # sep oznacava separator ## [1] &quot;Ja &lt;3 matf&quot; paste(1, 2, 3, sep = &quot; &lt; &quot;) # ako stavimo npr broj, pretvorice se u string ## [1] &quot;1 &lt; 2 &lt; 3&quot; c stil formatiranja sprintf(&quot;Broj %d. Izvucen je broj %d.&quot;, 7, 8) ## [1] &quot;Broj 7. Izvucen je broj 8.&quot; sprintf(&quot;Broj %.2f.&quot;, pi) # pi postoji kao konstanta, e ne postoji vec exp(1) ## [1] &quot;Broj 3.14.&quot; 1.1.4.2 glue - korisna biblioteka za rad sa stringovima stringova # install.packages(&quot;glue&quot;) # ovako se instaliraju paketi. library(glue) # ovako se ucitavaju paketi glue(&quot;{who} &lt;3 {what}&quot;, who = &quot;Ja&quot;, what = &quot;fon&quot;) ## Ja &lt;3 fon glue(&quot;{number} == {number}&quot;, number = 17) ## 17 == 17 istrazite sami paket, premocan je 1.2 Vektori vektori se prave sa funkcijom c (c = combine) c(1, 2, 3) ## [1] 1 2 3 precica za vektore ovog tipa: 1:3 ## [1] 1 2 3 c(1, 3, 45, 65) ## [1] 1 3 45 65 sve operacije nad brojevima mogu se primeniti i na vektore i primenjuju se element po element. Ako znate matlab, razlika je sto su u R sve operacije nad vektorima rade element po element, a za matricno mnozenje i slicno se koriste posebni operatori. Znaci a * b u R je isto kao a .* b u MATLAB c(1, 2) + c(3, 4) ## [1] 4 6 a &lt;- 1:10 # operator dodele je &lt;- b &lt;- 11:20 a * b ## [1] 11 24 39 56 75 96 119 144 171 200 a + b ## [1] 12 14 16 18 20 22 24 26 28 30 a ^ b ## [1] 1.000000e+00 4.096000e+03 1.594323e+06 2.684355e+08 3.051758e+10 ## [6] 2.821110e+12 2.326305e+14 1.801440e+16 1.350852e+18 1.000000e+20 Nad vektorima postoje razne funkcije poput sum, mean, var, sd, median, itd., a i sve elementarne funkcije koje postoje nad brojevima su vektorizovane za vektore, pa je npr. sin(c(1, 2)) = c(sin(1), sin(2)) sin(a) ## [1] 0.8414710 0.9092974 0.1411200 -0.7568025 -0.9589243 -0.2794155 ## [7] 0.6569866 0.9893582 0.4121185 -0.5440211 vektori mogu sadrzati elemente samo jednog primitivnog tipa c(1, 2) ## [1] 1 2 c(1L, 2L) ## [1] 1 2 c(&quot;a&quot;, &quot;b&quot;) ## [1] &quot;a&quot; &quot;b&quot; c(&quot;a&quot;, 2) ## [1] &quot;a&quot; &quot;2&quot; c(TRUE, FALSE) ## [1] TRUE FALSE Ukoliko se tipovi ne slazu, pretvorice se u najfleksibilniji tip, znaci logical -&gt; integer -&gt; numeric -&gt; character class(c(TRUE, 1L, 1, &quot;1&quot;)) ## [1] &quot;character&quot; I logicki operatori su vektorizovani, pa je 1:5 &lt;= c(1, 1, 2, 2, 5) # TRUE FALSE FALSE FALSE TRUE ## [1] TRUE FALSE FALSE FALSE TRUE postoje funkcije any, all kao u MATLAB-u any(rep(2, 3) &lt; 1:3) ## [1] TRUE all(rep(2, 3) &lt; 1:3) ## [1] FALSE Kad su logicki vektori u pitanju obratiti paznju na &amp; i &amp;&amp;, kao i | i || R INFERNO and and andand A &lt;- c(FALSE, TRUE, TRUE, FALSE) B &lt;- c(TRUE, FALSE, TRUE, FALSE) &amp; i | rade vektorski - element po element i vracaju vektor! A &amp; B ## [1] FALSE FALSE TRUE FALSE A | B ## [1] TRUE TRUE TRUE FALSE &amp;&amp; i || porede samo prve elemente A &amp;&amp; B ## [1] FALSE A || B ## [1] TRUE 1.3 Matrice matrice se prave funckijom matrix matrix(1:9, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 prvi argument oznacava elemente koje ce sadrzati, to je jedan vektor, pri cemu se u matricu upisuju po kolonama, ukoliko nije specificirano drugacije. nrow argument (ili ncol) specifikuju koliko vrsta ima matrica. matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 za lepsi zapis moze se koristiti byrow = TRUE i pisati ovako matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), byrow = TRUE, nrow = 3) ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 2 2 2 ## [3,] 3 3 3 Sve elementarne funkcije nad matricama rade kao nad vektorima, znaci vracaju matricu, a primenjuju funkciju na svaki element. Mnozenje matrica se radi operatorom %*%, transponovanje funkcijom t() A &lt;- matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), byrow = TRUE, nrow = 3) t(A) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 ## [3,] 1 2 3 A %*% A ## [,1] [,2] [,3] ## [1,] 6 6 6 ## [2,] 12 12 12 ## [3,] 18 18 18 Skalarno mnozenje se moze implementirati na vise nacina, npr u &lt;- c(1, 2, 3) v &lt;- c(4, 5, 6) sum(u * v) ## [1] 32 ili mnozenjem uTv t(u) %*% v ## [,1] ## [1,] 32 Primetimo da poslednji izraz vraca 1x1 matricu, a prvi vraca broj, tj vektor velicine 1. Sa as.numeric mozemo to srediti. as.numeric(t(u) %*% v) ## [1] 32 Vektori kad se tumace kao matrice su naravno kolone vektori. 1.4 Liste Liste su nizovi koji mogu da sadrze objekte razlicitih tipova. Prakticno mogu da sadrze kao svoje elemente bilo koji objekat u R-u: vektore, matrice, druge liste, itd. n &lt;- c(2, 3, 5) s &lt;- c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;, &quot;ee&quot;) b &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) lst &lt;- list(n, s, b) # lst sadrzi kopije od n, s, b lst[1] #niz n ## [[1]] ## [1] 2 3 5 lst[2] #niz s ## [[1]] ## [1] &quot;aa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot; &quot;ee&quot; Na ovaj način dobijamo kopije prvog, odnosno drugog člana liste Međutim ako hoćemo da direktno pristupimo članu liste koristimo [[ ]] lst[[1]] ## [1] 2 3 5 Tada možemo da menjamo sadržaj liste lst[[2]]&lt;-c(&quot;a&quot;,&quot;b&quot;) lst[[2]][1]&lt;-&quot;c&quot; Liste mogu imati i imena clanova, kojima se onda moze pristupati dolarima $. named_list &lt;- list(brojevi = 1:5, slova = c(&quot;a&quot;, &quot;b&quot;)) named_list$brojevi ## [1] 1 2 3 4 5 named_list[[1]] ## [1] 1 2 3 4 5 1.5 Dataframe Dataframe je najčešći način čuvanja podataka u R-u i vrlo je pogodan za rad i analizu. Služi za prikaz tabelarnih podataka, pa liči na matricu, s tim što je dataframe u snovi lista koja sadrži vektore jednakih dužina (kolone), pri čemu ti vektori ne moraju biti istog tipa. Dakle možemo imati jednu kolonu koju čine brojevi, a drugu tekstualni podaci. Dataframe se pravi na sledeći način: df &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;)) df ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci Ovako smo dobili dataframe sa dve kolone, od kojih je jedna numerička a druga tekstualna. str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ kolona1: num 1 2 3 ## $ kolona2: Factor w/ 3 levels &quot;drugi&quot;,&quot;prvi&quot;,..: 2 1 3 R podrazumevano pretvara tekstualne podatke u faktore, to možemo preduprediti ako dodamo argument stringsAsFactors = FALSE. df &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) str(df) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ kolona1: num 1 2 3 ## $ kolona2: chr &quot;prvi&quot; &quot;drugi&quot; &quot;treci&quot; df ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci Dva dataframe-a (koji imaju isi broj vrsta) se mogu spojiti da dobijemo više kolona korišćenjem funkcije cbind. df1 &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) df2 &lt;- data.frame(kolona3 = c(4,5,6), kolona4 = c(&quot;prvi1&quot;, &quot;drugi1&quot;, &quot;treci1&quot;), stringsAsFactors = FALSE) df3 &lt;- cbind(df1, df2) df3 ## kolona1 kolona2 kolona3 kolona4 ## 1 1 prvi 4 prvi1 ## 2 2 drugi 5 drugi1 ## 3 3 treci 6 treci1 Takodje, mogu se nadovezati po vrstama (ako imaju ista imena kolona) funkcijom rbind. df1 &lt;- data.frame(kolona1 = c(1, 2, 3), kolona2 = c(&quot;prvi&quot;, &quot;drugi&quot;, &quot;treci&quot;), stringsAsFactors = FALSE) df2 &lt;- data.frame(kolona1 = c(4,5,6), kolona2 = c(&quot;prvi1&quot;, &quot;drugi1&quot;, &quot;treci1&quot;), stringsAsFactors = FALSE) df4 &lt;- rbind(df1, df2) df4 ## kolona1 kolona2 ## 1 1 prvi ## 2 2 drugi ## 3 3 treci ## 4 4 prvi1 ## 5 5 drugi1 ## 6 6 treci1 Vrednostima kolona možemo pristupati pomoću operatora $, kao u listama, a istim možemo i dodati nove kolone. df$kolona1 ## [1] 1 2 3 df$kolona5 &lt;- c(7,8,9) df ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 2 2 drugi 8 ## 3 3 treci 9 Medjutim, možda elegantniji način filtriranja i odabira podskupova dataframe-a je korišćenjem uglatih zagrada. Koristimo notaciju df[redovi, kolone], gde prvim argumentom odredjujemo koje redove želimo da uzmemo, a drugim koje kolone. Prazno mesto za neki od argumenata znači “uzmi sve”. df[,] # sve ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 2 2 drugi 8 ## 3 3 treci 9 df[1,] # prva vrsta ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 df[,1] # prva kolona ## [1] 1 2 3 Redovi mogu biti ili vektori brojeva koji označavaju indekse redova koje da uzmemo, ili vektori TRUE/FALSE vrednosti iste dužine kao broj vrsta u dataframe-u, pri čemu se tada biraju redovi na pozicijama gde je u vektoru vrednost TRUE. df4[c(1,3,4), ] # sve kolone, redovi 1,3,4 ## kolona1 kolona2 ## 1 1 prvi ## 3 3 treci ## 4 4 prvi1 df4[df4$kolona1 &gt; 3, ] # sve kolone, one vrste kod kojih je kolona1 veca od 3 ## kolona1 kolona2 ## 4 4 prvi1 ## 5 5 drugi1 ## 6 6 treci1 Kolone mogu biti ili vektori brojeva koji označavaju koje kolone da uzmemo prema indeksu, ili vektori stringova, koji označavaju imena kolona koje da uzmemo. df3[, c(1,3)] # sve vrste, 1 i 3 kolona ## kolona1 kolona3 ## 1 1 4 ## 2 2 5 ## 3 3 6 df3[, c(&quot;kolona1&quot;, &quot;kolona3&quot;)] # isto ## kolona1 kolona3 ## 1 1 4 ## 2 2 5 ## 3 3 6 df3[c(1,3), c(&quot;kolona1&quot;, &quot;kolona3&quot;)] # prvi i treci red, prva i treca kolona ## kolona1 kolona3 ## 1 1 4 ## 3 3 6 Korisna stvar je da ako koristimo vektore brojeva za indeksiranje, ukoliko stavimo znak - ispred, to znači da izuzimamo te redove/kolone. df[, -1] # sve bez prve kolone ## kolona2 kolona5 ## 1 prvi 7 ## 2 drugi 8 ## 3 treci 9 df[-2, ] # sve bez druge vrste ## kolona1 kolona2 kolona5 ## 1 1 prvi 7 ## 3 3 treci 9 df[-c(1,2), c(&quot;kolona2&quot;, &quot;kolona5&quot;)] # druga i peta kolona, bez prve i druge vrste ## kolona2 kolona5 ## 3 treci 9 Konačno, za osnovne informacije o tabeli postoje funkcije colnames, rownames, ncol i nrow, za koje možete pretpostaviti šta rade. "],
["02-generisanje.html", "2 Generisanje slucajnih velicina 2.1 Primeri sa teorije verovatnoca 2.2 Metoda inverzne transformacije", " 2 Generisanje slucajnih velicina 2.1 Primeri sa teorije verovatnoca Pokazacemo kako se mogu generisati uzorci iz raspodela koje smo radili na Teoriji verovatnoca. 2.1.1 Prvi zadatak \\(X\\sim \\mathcal{U}(0,1)\\). Odrediti raspodelu: \\(Y = aX+b\\) \\(W = -\\log X\\) 2.1.1.1 Raspodela \\(Y = aX+b\\) Od ranije (sa TV-a), znamo da treba da bude \\(Y\\sim\\mathcal{U}(b, a+b)\\). # runif sluzi za generisanje slucajnih brojeva iz uniformne (0,1) raspodele x &lt;- runif(1e4) # nacrtamo histogram hist(x) # generisemo y po definiciji, uzimamo npr. a = 3, b = 7 y &lt;- 3 * x + 7 hist(y) Histogrami za x i y izgledaju slicno, kao uniformna raspodela (svi stupci su iste visine), ali nosac za y je od 7 do 10, sto je bas sto smo ocekivali. 2.1.1.2 Raspodela \\(W=-\\log X\\) Treba da bude \\(W\\sim\\mathcal{E}(1)\\). hist(x) # transformisemo x u w logaritmom w &lt;- -log(x) # crtamo histogram, probability argument obezbedjuje da na y osi budu # frekvencije umesto broj pojavljivanja. # Slika je ista, ali y osa je sad na (0,1) hist(w, probability = TRUE) # crtamo funkciju dexp - gustinu eksponencijalne raspodele # funkcija curve crta datu krivu # curve uvek prima izraz po x # xlim odredjujegranice x ose na grafiku # add = TRUE znaci da se doda na prethodni grafik curve(dexp(x), xlim = c(0, 5), add = TRUE, col = &quot;red&quot;) Vidimo da se dobro poklapaju histogram i teoretska gustina eksponencijalne raspodele. 2.1.2 Drugi zadatak \\(X \\sim \\mathcal{E}(\\lambda)\\). Odrediti raspodele: \\(Y = [X]\\) \\(W = 1-e^{-\\lambda X}\\) 2.1.2.1 Raspodela \\(Y\\) Treba da bude \\(Y \\sim\\mathcal{G}(1-e^{-\\lambda})\\) # sa rexp generisemo uzorak iz eksponencijalne raspodele x &lt;- rexp(1e4, rate = 0.1) #lambda = 0.1 hist(x, prob = TRUE) y &lt;- floor(x) # ceo deo je floor funkcija # crtamo histogram y hist(y, prob = TRUE) # sad cemo da nacrtamo preko histograma odgovarajuce vrednosti sa zakona # raspodele geometrijske raspodele, posto nemamo gustinu # uzecemo tacke od 1 do 50, jer geometrijska raspodela uzima vrednosti 1,2,... # (ogranicili smo se na 50 bez posebnog razloga, dovoljno je veliki broj) pts &lt;- seq_len(50) # i nacrtacemo vrednost zakona raspodele, koji se dobija funkcijom dgeom, # koristecu funkciju points, koja na postojeci grafik dodaje tacke. points(dgeom(pts, prob = 1-exp(-0.1)), col = &quot;red&quot;) 2.2 Metoda inverzne transformacije 2.2.1 Uvodni primeri Na Teoriji verovatnoca samo pokazali da ako je \\(X\\) slucajna velicina sa funkcijom raspodele \\(F_X\\), onda \\(Y=F_X(X)\\) ima uniformnu raspodelu na \\([0,1]\\) Slicno, ako je \\(U\\sim \\mathcal{U}[0,1]\\), onda \\(T=F_X^{-1}(U)\\) ima istu raspodelu kao \\(X\\). Pogledajmo neke primere u &lt;- runif(1e4) hist(u) Kada na u primenimo qnorm (inverz funkcije raspodele normalne raspodele), treba da dobijemo normalnu raspodelu. y &lt;- qnorm(u) hist(y) Ako zelimo da dobijemo normalnu raspodelu \\(\\mathcal{N}(2, 5)\\), to mozemo uraditi na vise nacina. Jedan je da transformisemo standardnu normalnu raspodelu linearnom transformacijom \\(\\sigma X + m\\), a drugi da prosto damo argumente mean i sd funkciji qnorm. y &lt;- qnorm(u) hist(sqrt(5)*y + 2) y &lt;- qnorm(u, mean = 2, sd = sqrt(5)) hist(y) Ako hocemo uzorak iz eksponencijalne raspodele, samo na u primenimo qexp sto predstavlja inver funkcije raspodele eksponencijalne raspodele. hist(qexp(u, rate = pi)) 2.2.2 Opsti generator Napravicemo sada opsti generator slucajnih brojeva iz apsolutno neprekidnih raspodela, trazenjem inverza funkcije raspodele numerickim metodama. Ovaj generator cemo moci da koristimo za generisanje uzoraka iz proizvoljne apsolutno neprekidne raspodele. Numericko trazenje inverza se zasniva na sledecem: Ako je \\(x = F^{-1}(t)\\), to znaci da je \\(t = F(x)\\), tj. \\(x\\) je resenje jednacine \\(F(x) - t = 0\\), tj. \\(x\\) je nula funkcije \\(g(x) = F(x) - t\\). Dakle, da bismo nasli numericki inverz neke funkcije \\(F\\), potrebno je da nadjemo nulu funkcije \\(g(x) = F(x) - t\\). Napravicemo prvo funkciju koja za datu funkciju i tacku \\(t\\) vraca inverz te funkcije u toj tacki. # Funkcija koja vraca inverz funkcije f u tacki t. # Domen funkcije f je argument support. # Primer: # f &lt;- pexp # inv(f, 0.3, c(0, 100000)) inv &lt;- function(f, t, support) { uniroot(function(x) f(x) - t, interval = support)$root } Testirajmo vrednost koju vraca. inv(pexp...)(pexp je funkcija raspodele) treba da se poklopi sa qexp. inv(pexp, 0.3, c(0, 1000)) ## [1] 0.3566753 qexp(0.3) ## [1] 0.3566749 Napravimo sada fuknciju koja ce da se koristi kao generator. # Kao argument funkcije primamo obim uzorka koji generisemo, # funkciju raspodele trazene raspodele i nosac raspodele. generator &lt;- function(n, cdf, support) { # inicijalizujemo uzorak kao prazan vektor od n elemenata sample &lt;- numeric(n) # generisemo n brojeva iz uniformne raspodele u &lt;- runif(n) # za svaki od brojeva u_i primenimo inverz funkcije raspodele for (i in 1:n) { sample[i] &lt;- inv(cdf, u[i], support) } # vracamo uzorak return(sample) } Testirajmo da li generator pravi dobar uzorak, na primeru normalne raspodele: x &lt;- generator(1000, pnorm, c(-1000, 1000)) hist(x) 2.2.2.1 Zadatak. Generisati uzorak obima 100 iz raspodele sa funkcijom raspodele \\(F(x) = \\begin{cases} 0,&amp; u &lt; 0 \\\\ 1 - e^{-\\lambda\\sqrt{u}},&amp; u \\geq0 \\end{cases}\\) lambda &lt;- 2 cdf &lt;- function(x) 1 - exp(-lambda*sqrt(x)) hist(generator(100, cdf, support = c(0, 10000))) "],
["03-matsum.html", "3 Matrix summary 3.1 Implementacija funkcije matrix_summary 3.2 Provera dijagonalnosti 3.3 Funkcija print_matrix_summary 3.4 Celokupni kod", " 3 Matrix summary Napravicemo funkciju ciji cilj je da odredi osnovna svojstva matrice, poput dimenzije, ranga, sopstvenih vrednosti, invertibilnosti, dijagonalnosti i slicno. Nakon toga napravicemo i funkciju koja stampa sazetak osnovnih svojstava matrice u lepom formatu, sa glue bibliotekom. Pisacemo red po red funkcije, uz detaljna objasnjenja, pa na kraju dati kompletan kod. 3.1 Implementacija funkcije matrix_summary Definisimo prvo funkciju, primace argument mat koji predstavlja matricu matrix_summary &lt;- function(mat) { # ... Izlaz ce nam biti lista koja sadrzi trazena svojstva matrice. Biramo listu kao izlazni tip, jer zelimo da skladistimo objekte raznih dimenzija i tipova, pa se ne mozemo zadovoljiti vektorskim tipom. Dakle, kreiramo praznu listu, koju cemo dalje popunjavati. output &lt;- list() Za pocetak dodacemo u listu izlaza matricu koju analiziramo, kao i dimenzije output$matrix &lt;- mat output$dimensions &lt;- dim(mat) Sledeci je rang matrice. Njega cemo racunati pomocu funkcije rankMatrix iz Matrix paketa library(Matrix) output$rank &lt;- rankMatrix(mat) Da li je matrica kvadratna cemo proveriti uporedjivanjem dimenzija matrice. Ukoliko je razlika broja kolona i vrsta jednaka 0, to znaci da je matrica kvadratna. output$is_square &lt;- diff(dim(mat)) == 0 Dalja svojstva matrice koja cemo gledati su: kvadratnost, inveritbilnost, inverz, sopstvene vrednosti, simetricnost i dijagonalnosti. Ova svojstva imaju smisla samo za kvadratne matrice, pa ce to biti uslov da razmatramo ova svojstva. if (output$is_square) { # ... Da li je matrica singularna (tj. nema inverz) proveravamo tako sto pogledamo da li je rang matrice razlicit od broja vrsta, jer je matrica invertibilna akko je punog ranga. output$is_singular &lt;- output$rank != dim(mat)[1] Ukoliko matrica nije singularna, ima smisla izracunati joj inverz. Za to koristimo funkciju solve, koja sluzi za resavanje sistema oblika \\(Ax = b\\), dok ako joj se prosledi samo matrica, ona vraca inverz te matrice kao rezultat (za detalje pogledati dokumentaciju ?solve). if (!output$is_singular) { output$inverse &lt;- solve(mat) } Za determinantu, imamo funkciju det… output$determinant &lt;- det(mat) Sopstvene vrednosti racunamo funkcijom eigen, koja kao rezultat vraca listu, ciji je jedan od elemenata $values – vektor sopstvenih vrednosti. output$eigenvalues &lt;- eigen(mat)$values Simetricnost matrice proveravamo tako sto posmatramo da li je jednaka svom transponatu. output$is_symmetric &lt;- all(mat == t(mat)) Za odredjivanje da li je matrica dijagonalna, implementiracemo u nastavku sopstvenu funkciju, za sad cemo samo dodati u listu svojstava njenu vrednost. output$is_diagonal &lt;- is_diagonal2(mat) Na kraju zatvaramo if i vracamo konstruisanu izlaznu listu. # ... } return(output) } 3.2 Provera dijagonalnosti Radi provere dijagonalnosti, dacemo dve razlicite implementacije, pa cemo ih uporediti sa stanovista brzine i odabrti najbolju za nasu funkciju. 3.2.1 Implementacija 1 Prva implementacija se zasniva na jednostavnom prolazenju kroz matricu i ukoliko nadjemo element van dijagonale koji nije nula, vratimo FALSE. is_diagonal &lt;- function(mat) { # Ukoliko argument mat nije matrica, javljamo gresku if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } # Prolazimo kroz sve redove... for (i in 1:nrow(mat)) { # ...i sve kolone for (j in 1:ncol(mat)) { # ako smo van dijagonale, i matrica na tom mestu nije nula, # zakljucujemo da matrica nije dijagonalna, i vracamo FALSE if (i != j &amp;&amp; mat[i,j] != 0) return(FALSE) } } # U opstem slucaju vracamo TRUE return(TRUE) } 3.2.2 Implementacija 2 Druga implementacija se oslanja na to da, kada dijagonalnu matricu element po element pomnozimo sa jedinicnom, na kraju opet dobijamo istu tu matricu. Par primera: A &lt;- matrix(1:4, ncol = 2) B &lt;- diag(c(3, 8)) E &lt;- diag(2) A ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 B ## [,1] [,2] ## [1,] 3 0 ## [2,] 0 8 E ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 A * E # nedijagonalna ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 4 B * E # dijagonalna ## [,1] [,2] ## [1,] 3 0 ## [2,] 0 8 To svojstvo mozemo lako implementirati… is_diagonal2 &lt;- function(mat) { if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } # Proverimo da li su svi elementi matrice mat, pomnozene identickom # matricom, jednaki originalnoj matrici mat. Pogledati dokumentaciju # funkcije diag (?diag) all(mat * diag(nrow(mat)) == mat) } 3.2.3 Poredjenje brzine implementacija Za poredjenje brzine implementacija koristicemo biblioteku microbenchmark. # install.packages(&quot;microbenchmark&quot;) library(microbenchmark) Uporedicemo brzinu funkcija is_diagonal i is_diagonal2 za 2 razlicite matrice, jednu dijagonalnu i jednu ne-dijagonalnu. diag_matrix &lt;- diag(300) # 100x100 dijagonalna matrica nondiag_matrix &lt;- matrix(rnorm(9e4), ncol = 300) # random matrica 100x100 Poredjenje za nedijagonalnu: microbenchmark(is_diagonal(nondiag_matrix), is_diagonal2(nondiag_matrix)) ## Unit: microseconds ## expr min lq mean median uq ## is_diagonal(nondiag_matrix) 1.739 2.461 75.21515 3.6405 5.2460 ## is_diagonal2(nondiag_matrix) 419.566 432.814 723.18015 494.0905 909.5165 ## max neval ## 7120.445 100 ## 3835.663 100 U ovom slucaju je brza prva implementacija. Pogledajmo i poredjenje za dijagonalnu matricu. microbenchmark(is_diagonal(diag_matrix), is_diagonal2(diag_matrix)) ## Unit: microseconds ## expr min lq mean median uq ## is_diagonal(diag_matrix) 7816.645 7921.558 7996.498 7960.319 8033.083 ## is_diagonal2(diag_matrix) 632.601 1024.513 1071.934 1038.288 1064.657 ## max neval ## 8942.004 100 ## 4636.436 100 U ovom slucaju je druga implementacija ubedljivo brza. Ako pogledamo pazljivije, druga implementacija ima u oba slucaja isto vreme, dok se u prvoj implementaciji sa for petljom vremena drasticno razlikuju. Razlog za to je sto u is_diagonal, ako naidjemo na nenula element van dijagonale, odmah izlazimo iz funkcije, a to se desava prilicno brzo, jer vec u drugoj iteraciji petlje dodjemo na neki element van dijagonale. S druge strane, ako imamo dijagonalnu matricu, moramo da prodjemo kroz sve elemente matrice da bismo zakljucili da zaista nisu nule, a to zahteva veliko vreme. Ali avaj! Kada razmislite, druga, brza implementacija uvek mnozi svaki element sa svakim, pa poredi da li su svi elementi neke dve matrice jednaki, sto je mnogo operacija. Zasto je prolazak kroz sve elemente matrice u for petlji bio toliko skup, a u is_diagonal2, gde mnozimo sve elemente matrice (i cak imamo veci broj operacija!) nemamo tu kaznu u vremenu izvrsavanja? Odgovor je u tome sto su mnozenje matrica, poredjenja matrica, i sve operacije nad vektorima i matricama u R-u u pozadini implmentirane u programskom jeziku C ili Fortran-u, koji su kompajlirani jezici i neuporedivo su brzi nego rucno prolazenje kroz petlju u R. Dakle, glavno pravilo kod pisanja brzog koda u R-u je da se oslanjate u sto vecoj meri na ugradjenje funkcije, umesto pravljenja svojih. Takodje, for petlje treba izbegavati u sirokom luku, jer vrlo postoji bolje resenje, a petlje dovode do slabe brzine kode. 3.3 Funkcija print_matrix_summary Sada cemo napisati jednostavnu funkciju koja ce nase zakljucke iz funkcije matrix_summary napisati kao kratak opis matrice. Neki primeri koje bismo ocekivali: “m by n matrix of rank r” “n by n square, symmetric, nonsingular matrix of rank n” “n by n square, singular matrix of rank 7” Definisimo prvo funkciju, primace argument mat koji predstavlja matricu print_matrix_summary &lt;- function(mat) { # ... Ucitacemo biblioteku glue koju cemo koristiti za pravljenje poruke. library(glue) Ucitacemo rezultat matrix_summary funkcije, na osnovu kog cemo praviti sazeti opis matrice. mat_summary &lt;- matrix_summary(mat) Imamo dva glavna slucaja - kvadratne i nekvadratne matrice. Ako matrica nije kvadratna, nemamo neki poseban rezultat, vec samo znamo dimenziju i rang, pa cemo samo to istampati # ako nije kvadratna... if (!mat_summary$is_square) { # ... istampaj... print( # ... poruku koja je oblika &quot;m by n matrix of rank r&quot; # funkcija glue dopusta koriscenje vrednosti promenljivih ako se pisu # unutar zagrada { } i on ce zameniti taj izraz njegovom vrednoscu. glue(&quot;{dim(mat)[1]} by {dim(mat)[2]} matrix of rank {mat_summary$rank}&quot;) ) } Ako je matrica kvadratna, onda imamo nekoliko svojstava koje zelimo da proverimo i da ispisemo. String koji cemo da ispisemo cemo praviti nadovezivanjem svakog svojstva jedno po jedno, pocevsi od praznog stringa. else { # string koji sadrzi svojstva matrice cemo inicijalizovati kao prazan properties &lt;- &quot;&quot; # ako je matrica simetricna, dodacemo string &quot;, symmetric&quot; na string # properties if (mat_summary$is_symmetric) properties &lt;- glue(properties, &quot;, symmetric&quot;) # ako je matrica dijagonalna, dodajemo string &quot;, diagonal&quot; na string # properties (kao rezultat dobijamo &quot;, symmetric, diagonal&quot;) if (mat_summary$is_diagonal) properties &lt;- glue(properties, &quot;, diagonal&quot;) # konacno, dodajemo string &quot;, singular&quot; ako je matrica singularna # (nema inverz) ili string &quot;, nonsingular&quot; ako matrica nije singularna. properties &lt;- glue(properties, ifelse(mat_summary$is_singular, &quot;, singular&quot;, &quot;, nonsingular&quot;)) # properties string sada ima oblik slican ovom: # &quot;, symmetric, diagonal, nonsingular&quot; i ideja je da ga nadovezemo na string # &quot;m by n square&quot;, i na rezultat dodamo &quot; matrix of rank r&quot;, cime bi kao # rezultat dobili string tipa: # &quot;m by n square&quot;+&quot;, symmetric, diagonal, nonsingular&quot;+&quot; matrix of rank r&quot; = # &quot;m by n square, symmetric, diagonal, nonsingular matrix of rank r&quot; print( # funkcija glue po default-u nadovezuje argumente koji su joj prosledjeni. glue( &quot;{dim(mat)[1]} by {dim(mat)[2]} square{properties}&quot;, &quot; matrix of rank {mat_summary$rank}&quot; ) ) } 3.4 Celokupni kod # Returns whether the given matrix is diagonal is_diagonal &lt;- function(mat) { if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } for (i in 1:nrow(mat)) { for (j in 1:ncol(mat)) { if (i != j &amp;&amp; mat[i,j] != 0) return(FALSE) } } return(TRUE) } is_diagonal2 &lt;- function(mat) { if (!is.matrix(mat)) { stop(&quot;Not a matrix&quot;) } all(mat * diag(nrow(mat)) == mat) } # Matrix summary # Inputs: matrix mat # Outputs: Basic properties od the matrix # E.g. Square? Diagonal? Symmetric? Rank, dimensions, # eigenvalues, inverse, Singular?, determinant matrix_summary &lt;- function(mat) { output &lt;- list() output$matrix &lt;- mat output$dimensions &lt;- dim(mat) library(Matrix) output$rank &lt;- rankMatrix(mat) output$is_square &lt;- diff(dim(mat)) == 0 if (output$is_square) { output$is_singular &lt;- !(output$rank == dim(mat)[1]) if (!output$is_singular) { output$inverse &lt;- solve(mat) } output$determinant &lt;- det(mat) output$eigenvalues &lt;- eigen(mat)$values output$is_symmetric &lt;- all(mat == t(mat)) output$is_diagonal &lt;- is_diagonal2(mat) } class(output) &lt;- &quot;matrixSummary&quot; return(output) } # Prints out matrix description # E.g. &quot;m by n matrix of rank r&quot; # &quot;n by n square, symmetric, nonsingular matrix of rank n&quot; # &quot;n by n square, singular matrix of rank 7&quot; print_matrix_summary &lt;- function(mat) { library(glue) mat_summary &lt;- matrix_summary(mat) if (!mat_summary$is_square) { print( glue(&quot;{dim(mat)[1]} by {dim(mat)[2]} matrix of rank {mat_summary$rank}&quot;) ) } else { properties &lt;- &quot;&quot; if (mat_summary$is_symmetric) properties &lt;- glue(properties, &quot;, symmetric&quot;) if (mat_summary$is_diagonal) properties &lt;- glue(properties, &quot;, diagonal&quot;) properties &lt;- glue(properties, ifelse(mat_summary$is_singular, &quot;, singular&quot;, &quot;, nonsingular&quot;)) print( glue( &quot;{dim(mat)[1]} by {dim(mat)[2]} square{properties}&quot;, &quot; matrix of rank {mat_summary$rank}&quot; ) ) } } "],
["04-apply.html", "4 *apply funkcije 4.1 Funkcija sapply 4.2 Funkcija lapply 4.3 Funkcija apply", " 4 *apply funkcije Upoznacemo se u ovom poglavlju sa *apply familijom funkcija, i to: apply, sapply i lapply funkcijama, koje cine osnovu funkcionalnog programiranja u R-u. U pitanju su funkcije koje sluze za preslikavanje elemenata vektora/matrica/listi u nove vektore/matrice/liste primenom jedne iste funkcije na svaki element. Pre svega, napomenuo bih da lep tutorijal sa lepim slikama koje ilustruju ove funkcije ima na https://www.datacamp.com/community/tutorials/r-tutorial-apply-family 4.1 Funkcija sapply Najjednostavnija od apply funkcija, funkcija sapply se poziva ovako: sapply(v, f), gde je v vektor/lista/matrica, a f funkcija koju treba primeniti na svaki element od v. Dobijamo preslikavanje: \\[v = (v_1, v_2, \\dots, v_n)\\stackrel{sapply}{\\rightarrow} (f(v_1), f(v_2), \\dots, f(v_n)).\\] Dakle, sapply primenjuje datu funkciju na svaki element datog vektora/liste/matrice i vraca rezultujuci vektor. Treba napomenuti da uvek pokusava da kao rezultat vrati vektor, a ukoliko to nije moguce, vraca listu. 4.1.1 Par kratkih primera Prost primer za sapply je kvadriranje svakog clana vektora x &lt;- 1:5 sapply(x, function(num) num^2) ## [1] 1 4 9 16 25 Ovaj kod je ekvivalentan sa x^2. Funkcija sapply ne mora da prima vektor kao argument vec moze primiti i listu. Kao izlaznu vrednosti opet ce dati vektor. Evo primera ako zelimo da za neku listu matrica zelimo da izracunamo sumu svih vrednosti u matrici. matrix_list &lt;- list(diag(5), diag(7), matrix(1:10, nrow=2)) # na svaku matricu iz matrix_list primenimo funkciju sum matrix_sums &lt;- sapply(matrix_list, sum) matrix_sums ## [1] 5 7 55 Ovo je naravno isto sto i c(sum(diag(5)), sum(diag(7)), sum(matrix(1:10, nrow=2))) ## [1] 5 7 55 Ukoliko se primenjuje visedimenziona funkcija, sapply moze vratiti i matricu. Na primer: sapply(1:5, function(k) c(k, k^2)) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 1 4 9 16 25 Svaka kolona je jedan rezultat primenjene funkcije. Vidimo da je prva vrsta k, a druga vrsta k^2. 4.1.2 Lepsi generator slucjanih velicina Kao bolji primer koriscenja sapply vraticemo se na nas generator metodom inverzne transformacije. generator &lt;- function(n, cdf, support) { # inicijalizujemo uzorak kao prazan vektor od n elemenata sample &lt;- numeric(n) # generisemo n brojeva iz uniformne raspodele u &lt;- runif(n) # za svaki od brojeva u_i primenimo inverz funkcije raspodele for (i in 1:n) { sample[i] &lt;- inv(cdf, u[i], support) } # vracamo uzorak return(sample) } Vidimo da je ceo kod u generatoru zasnovan na tome da generisemo \\(n\\) brojeva iz uniformne raspodele, pa na svaki od njih primenimo funkciju function(u) inv(cdf, u, support) (u[i] zamenjeno sa u). Ovo je bas ono sto ocekujemo od sapply funkcije! Stoga promenimo kod generatora da to iskoristi. generator &lt;- function(n, cdf, support) { # generisemo n brojeva iz uniformne raspodele u &lt;- runif(n) # na svaki element iz u primenimo inverznu transformaciju sample &lt;- sapply(u, function(u) inv(cdf, u, support)) return(sample) } To je ceo kod! Sveli smo kod prakticno na 2 reda, jer smo izbacili tehnicke stvari poput inicijalizacije vektora koji vracamo, prolazenja kroz petlju i popunjavanja rezultujuceg vektora clan po clan. Ostao je kod koji sadrzi samo sustinu onoga sto hocemo da uradimo: uzmemo uzorak iz uniformne raspodele (u &lt;- runif(n)) Svaki element uzorka transformisemo inverznom transformacijom (sapply(u, function(u) inv(cdf, u, support))) Nista vise od toga nije trazeno u matematickom zapisu metoda, pa nema potrebe ni da komplikujemo kod. Upravo to je (pored brzine i nekih tehnickih stvari poput bolje otpornosti na greske od petlji) glavna prednost *apply funkcija naspram petlji – kod cine mnogo citljivijim (nakon sto je korisnik upoznat sa ovim funkcijama, naravno). 4.2 Funkcija lapply Funkcija lapply se koristi na isti nacin kao i sapply, s tim sto kao rezultat vraca listu, a ne vektor. Dakle, ukoliko ne ocekujemo rezultat da bude jednog te istog tipa i dimenzije, vec zelimo da izlaz bude lista, onda koristimo lapply. Na primer, ako zelimo za neki vektor brojeva napravimo listu dijagonalnih matrica odgovarajuce dimenzije, to mozemo da uradimo sa dimensions &lt;- c(1, 3, 5) lapply(dimensions, function(d) diag(d)) ## [[1]] ## [,1] ## [1,] 1 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 ## ## [[3]] ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0 0 0 0 ## [2,] 0 1 0 0 0 ## [3,] 0 0 1 0 0 ## [4,] 0 0 0 1 0 ## [5,] 0 0 0 0 1 Dobili smo listu dijagonalnih matrica dimenzija 1, 3 i 5. Da smo koristili petlje, ovaj kod bi bio dosta nezgrapniji: result &lt;- list() i &lt;- 1 for (d in dimensions) { result[[i]] &lt;- diag(d) i &lt;- i + 1 } result ## [[1]] ## [,1] ## [1,] 1 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 ## ## [[3]] ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0 0 0 0 ## [2,] 0 1 0 0 0 ## [3,] 0 0 1 0 0 ## [4,] 0 0 0 1 0 ## [5,] 0 0 0 0 1 Moramo da inicijalizujemo listu, da vodimo racuna o brojacu i da element po element dopunjujemo rezultujucu listu. 4.3 Funkcija apply Funkcij apply je funkcija koja se koristi kada imamo visedimenzioni ulaz, poput matrice ili dataframe-a, a zelimo da primenimo neku funkciju po kolonama ili po vrstama (ili nekoj trecoj dimenziji ukoliko postoji). Funkcija se poziva kao apply(mat, dim, f), gde je m matrica/dataframe, dim je dimenzija po kojoj primenjujemo funkciju (1 je za vrste, 2 je za kolone), a f je funkcija koju da primenimo na svaku vrstu/kolonu. Primenom apply dobijamo preslikavanje (po vrstama - dim = 1) \\[ \\begin{pmatrix}1 &amp; 3 &amp; 5\\\\ 2 &amp; 4 &amp; 6\\end{pmatrix} \\stackrel{apply(\\cdot, 1, f)}{\\longrightarrow} \\begin{pmatrix}f(1, 3, 5)\\\\ f(2, 4, 6)\\end{pmatrix} \\] ili po kolonama (dim = 2) \\[ \\begin{pmatrix}1 &amp; 3 &amp; 5\\\\ 2 &amp; 4 &amp; 6\\end{pmatrix} \\stackrel{apply(\\cdot, 2, f)}{\\longrightarrow} \\left(f\\binom12, f\\binom34, f\\binom56\\right) \\] Na primer, moze se odrediti zbir elemenata u svakoj koloni neke matrice. mat &lt;- matrix(1:12, ncol = 4) mat ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 apply(mat, 2, sum) ## [1] 6 15 24 33 Ovo je ekvivalentno pozivu colSums(mat) ## [1] 6 15 24 33 Ako zelimo prosek po vrstama, mozemo pozvati apply(mat, 1, mean) ## [1] 5.5 6.5 7.5 Sto je isto kao i rowMeans(mat) ## [1] 5.5 6.5 7.5 Rezultat ne mora biti vektor, mozemo vratiti rezultat poziva summary na svaku kolonu dataframe-a i dobijamo matricu. cars #ugradjen skup podataka u R ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 ## 5 8 16 ## 6 9 10 ## 7 10 18 ## 8 10 26 ## 9 10 34 ## 10 11 17 ## 11 11 28 ## 12 12 14 ## 13 12 20 ## 14 12 24 ## 15 12 28 ## 16 13 26 ## 17 13 34 ## 18 13 34 ## 19 13 46 ## 20 14 26 ## 21 14 36 ## 22 14 60 ## 23 14 80 ## 24 15 20 ## 25 15 26 ## 26 15 54 ## 27 16 32 ## 28 16 40 ## 29 17 32 ## 30 17 40 ## 31 17 50 ## 32 18 42 ## 33 18 56 ## 34 18 76 ## 35 18 84 ## 36 19 36 ## 37 19 46 ## 38 19 68 ## 39 20 32 ## 40 20 48 ## 41 20 52 ## 42 20 56 ## 43 20 64 ## 44 22 66 ## 45 23 54 ## 46 24 70 ## 47 24 92 ## 48 24 93 ## 49 24 120 ## 50 25 85 apply(cars, 2, summary) ## speed dist ## Min. 4.0 2.00 ## 1st Qu. 12.0 26.00 ## Median 15.0 36.00 ## Mean 15.4 42.98 ## 3rd Qu. 19.0 56.00 ## Max. 25.0 120.00 Rezultat je matrica u kojoj svaka kolona sadrzi rezultat poziva summary na odgovarajucu kolonu iz skupa podataka cars (kolone su speed i dist) 4.3.1 Standardizacija kolona dataframe-a Cesto je neophodno standradizovati kolone dataframe-a, primenom transformacije \\(\\frac{X-m}{\\sigma}\\), da bismo dobili promenljivu sa ocekivanjem \\(0\\) i disperzijom \\(1\\). To mozemo lako odraditi funkcijom apply. Na primer, standardizovacemo kolone iz cars skupa podataka. scaled_cars &lt;- apply(cars, 2, function(x){ (x - mean(x)) / sd(x) }) scaled_cars ## speed dist ## [1,] -2.15596948 -1.59025960 ## [2,] -2.15596948 -1.27981361 ## [3,] -1.58860909 -1.51264810 ## [4,] -1.58860909 -0.81414462 ## [5,] -1.39948896 -1.04697911 ## [6,] -1.21036883 -1.27981361 ## [7,] -1.02124870 -0.96936762 ## [8,] -1.02124870 -0.65892162 ## [9,] -1.02124870 -0.34847563 ## [10,] -0.83212857 -1.00817336 ## [11,] -0.83212857 -0.58131012 ## [12,] -0.64300844 -1.12459061 ## [13,] -0.64300844 -0.89175612 ## [14,] -0.64300844 -0.73653312 ## [15,] -0.64300844 -0.58131012 ## [16,] -0.45388831 -0.65892162 ## [17,] -0.45388831 -0.34847563 ## [18,] -0.45388831 -0.34847563 ## [19,] -0.45388831 0.11719336 ## [20,] -0.26476818 -0.65892162 ## [21,] -0.26476818 -0.27086413 ## [22,] -0.26476818 0.66047385 ## [23,] -0.26476818 1.43658884 ## [24,] -0.07564805 -0.89175612 ## [25,] -0.07564805 -0.65892162 ## [26,] -0.07564805 0.42763936 ## [27,] 0.11347208 -0.42608713 ## [28,] 0.11347208 -0.11564113 ## [29,] 0.30259221 -0.42608713 ## [30,] 0.30259221 -0.11564113 ## [31,] 0.30259221 0.27241636 ## [32,] 0.49171234 -0.03802963 ## [33,] 0.49171234 0.50525085 ## [34,] 0.49171234 1.28136584 ## [35,] 0.49171234 1.59181183 ## [36,] 0.68083247 -0.27086413 ## [37,] 0.68083247 0.11719336 ## [38,] 0.68083247 0.97091984 ## [39,] 0.86995260 -0.42608713 ## [40,] 0.86995260 0.19480486 ## [41,] 0.86995260 0.35002786 ## [42,] 0.86995260 0.50525085 ## [43,] 0.86995260 0.81569685 ## [44,] 1.24819285 0.89330835 ## [45,] 1.43731298 0.42763936 ## [46,] 1.62643311 1.04853134 ## [47,] 1.62643311 1.90225783 ## [48,] 1.62643311 1.94106357 ## [49,] 1.62643311 2.98881880 ## [50,] 1.81555324 1.63061758 Izracunajmo prosek i disperziju originalnih i skaliranih podataka (zaokruzeno na 2 decimale): round(apply(cars, 2, function(x) c(mean(x), var(x))), 2) ## speed dist ## [1,] 15.40 42.98 ## [2,] 27.96 664.06 round(apply(scaled_cars, 2, function(x) c(mean(x), var(x))), 2) ## speed dist ## [1,] 0 0 ## [2,] 1 1 Dakle, ocekivano, skalirani podaci su takvi da su prosek i standardna devijacija svake od kolona, redom, 0 i 1. "],
["05-uus.html", "5 Uvod u statistiku 5.1 Intervali poverenja 5.2 Studentov t test 5.3 Neparametarski testovi", " 5 Uvod u statistiku R je napravljen od strane statisticara, i namena mu je prevashodno bas primena statistickih metoda na racunaru. Stoga je vrlo pogodan za implementaciju raznih statistickih alata o kojima smo ucili na Uvodu u statistiku, a skoro svi su vec i implementirani u nekom od nebrojano mnogo paketa na CRAN repozitorijumu. Za vecinu metoda koje biste zeleli da primenite u statistici, verovatno postoji bar 1 paket koji to vec radi, pa mozete preskociti rucnu implementaciju. U ovom, poslednjem, poglavlju cemo proci kroz neke od statistickih testova koje smo prosli na kursu Uvod u statistiku. Pre svega, reklama… Ukoliko vam treba da formule iz pdf-ova pretvarate u LaTeX bez prekucavanja, koristite program MathPix. 5.1 Intervali poverenja Pre testova, podseticemo se intervala poverenja i implementirati ih u R-u. Ako pretpostavimo uzorak \\(X_1, \\dots, X_n\\) potice iz normalne raspodele \\(\\mathcal{N}(m, \\sigma^2)\\), znamo da vazi sledece \\[ \\frac{\\overline{X} - m}{\\widetilde{S}}\\sqrt{n} \\sim t_{n-1}, \\] gde je \\(\\overline{X}\\) uzoracka sredina, a \\(\\widetilde{S}\\) (popravljena) uzoracka standardna devijacija. Imajuci u vidu ovu raspodelu, interval poverenja nivoa \\(\\beta\\) za parametar \\(m\\) se lako izvodi i dobija se da je jednak \\[ \\left( \\overline{X} - C\\frac{\\widetilde{S}}{\\sqrt{n}},\\quad \\overline{X} + C\\frac{\\widetilde{S}}{\\sqrt{n}}\\right), \\] gde je \\(C = F^{-1}_{t_{n-1}}(\\frac{1+\\beta}2)\\). Ovakav interval se moze koristiti ne samo za normalnu raspodelu, vec primenu nalazi i za druge raspodele kada je uzorak jako veliki, zbog efekta centralne granicne teoreme. Naravno, u tom slucaju trazi se interval poverenja za ocekivanje date raspodele, sto je u slucaju normalne bas \\(m\\). Implementiracemo sad funkciju koja za dati uzorak vraca ovaj interval poverenja, pa se malo pozabaviti interpretacijom. confidence_interval &lt;- function(x, beta = 0.95) { n &lt;- length(x) # obim uzorka # iz formule vrednost C - kvantil t raspodele C &lt;- qt((1 + beta)/2, df = n - 1) # vracamo interval poverenja c( mean(x) - C * sd(x) / sqrt(n), mean(x) + C * sd(x) / sqrt(n) ) } Primer upotrebe: x &lt;- rnorm(50) confidence_interval(x, 0.95) ## [1] -0.3834597 0.1940241 Obratimo paznju na trenutak na interpretaciju nivoa poverenja \\(\\beta\\). To je verovatnoca da dobijeni interval poverenja obuhvati stvarnu vrednost parametra \\(m\\). To znaci (ako je \\(\\beta=0.95\\)) da ako mnogo puta izvucemo uzorak, u \\(95%\\) slucajeva ce interval poverenja sadrzati vrednost \\(m\\). Ispitajmo to: Prvo generisemo 10000 uzoraka i odgovarajucih intervala poverenja intervals &lt;- replicate(1e4, { x &lt;- rnorm(50) confidence_interval(x, 0.95) }) intervals[, 1:5] ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.1358313 -0.1580114 -0.4081886 -0.2097923 -0.3424593 ## [2,] 0.3367278 0.3926643 0.1032177 0.3635308 0.2798359 dim(intervals) ## [1] 2 10000 Kao rezultat poziva replicate dobijamo matricu sa 2 vrste i 10000 kolona, gde svaka kolona predstavlja jedan interval poverenja. Pogledajmo koliko od tih intervala poverenja sadrzi nulu, koja je bila stvarna vrednost parametra \\(m\\) (rnorm po default-u uzima \\(m=0, \\sigma=1\\)): # pravimo logicki vektor koji oznacava da li interval sadrzi nulu contains_zero &lt;- apply(intervals, 2, function(interval) { interval[1] &lt; 0 &amp;&amp; 0 &lt; interval[2] }) # gledamo u koliko intervala je sadrzana nula mean(contains_zero) ## [1] 0.9491 Vidimo da je nula sadrzana u \\(94.9%\\) intervala, sto je jako blizu trazenog nivoa poverenja od \\(95%\\). Rekli smo da se ovaj interval moze primeniti i na neke druge raspodele kad je uzorak veliki (za trazenje intervala poverenja za ocekivanje), pa mozemo i to probati, na primer na eksponencijalnoj raspodeli. mean(replicate(1e4, { lambda = 2 x &lt;- rexp(1000, 2) interval &lt;- confidence_interval(x, 0.95) interval[1] &lt; 1/lambda &amp;&amp; 1/lambda &lt; interval[2] })) ## [1] 0.9498 Opet nam je u \\(94.9%\\) slucajeva stvarna vrednost ocekivanja \\(\\frac1\\lambda = 1/2\\) upala u intervale poverenja. 5.2 Studentov t test 5.2.1 Slucaj jednog uzorka Ako imamo uzorak iz normalne \\(\\mathcal{N}(m, \\sigma^2)\\) raspodele, mozemo testirati hipotezu \\[H_0: m = m_0,\\] naspram neke od alternativa oblika \\[H_1: \\begin{cases}m&lt; m_0\\\\m\\neq m_0\\\\m &gt; m_0\\end{cases}.\\] Za to mozemo da koristimo test statistiku \\[t= \\frac{\\overline{X} - m_0}{\\widetilde{S}}\\sqrt{n} \\sim t_{n-1}.\\] Kriticna oblast ovog testa, sa nivoom \\(\\alpha\\) je oblika (za odgovarajuce alternative) \\[W = \\begin{cases}\\{t &lt; F^{-1}_{t_{n-1}}(\\alpha)\\}\\\\ \\{ |t| &gt; F^{-1}_{t_{n-1}}(1-\\frac\\alpha2)\\}\\\\\\{t &gt; F^{-1}_{t_{n-1}}(1-\\alpha)\\}\\end{cases}.\\] Cesci nacin na koji se u statistickim paketima vrsi testiranje je nalazenje p vrednosti testa, pa poredjenje te vrednosti sa nivoom znacajnosti. P vrednst testa se ugrubo moze opisati kao “kolicina dokaza za nultu hipotezu”, pa ukoliko je velika (\\(p&gt;\\alpha\\)), onda ne odbacujemo nultu hipotezu, a ako je \\(p &lt; \\alpha\\), onda odbacujemo nultu hipotezu u korist alternativne. P vrednost mozemo da izracunamo (u dvostranoj nultoj hipotezi slicno za ostale) kao \\[p = P\\{|t| &gt; |t_0|\\},\\] gde je \\(t_0\\) realizovana vrednost test statistike na osnovu uzorka. U slucaju \\(t\\) testa, p vrednost ce biti jednaka \\[ p = \\begin{cases}F_{t_{n-1}}(t_0)\\\\ 2(1-F_{t_{n-1}}(|t_0|))\\\\ 1 - F_{t_{n-1}}(t_0)\\end{cases}, \\] za odgovarajuce alternativne hipoteze, redom. Implementiracemo ovaj test za jedan uzorak, pa cemo nadalje koristiti ugradjenu funkciju u R-u t.test. pval_t_test &lt;- function(x, m0, alternative){ n &lt;- length(x) stat &lt;- (mean(x) - m0)/sd(x)*sqrt(n) if(alternative == &quot;less&quot;) { pval &lt;- pt(stat, df = n - 1) } else if(alternative == &quot;two.sided&quot;) { pval &lt;- 2 * (1 - pt(abs(stat), df = n - 1)) } else if(alternative == &quot;greater&quot;) { pval &lt;- 1 - pt(stat, df = n - 1) } else { stop(&quot;Unknown alternative&quot;) } return(pval) } Ugradjena funkcija u R-u koja sprovodi \\(t\\) test se naziva t.test. Uporedicemo rezultate nase i ugradjene funkcije: x &lt;- rnorm(50, 1, 2) pval_t_test(x, 1, &quot;two.sided&quot;) ## [1] 0.03838225 t.test(x, mu=1, alternative = &quot;two.sided&quot;) ## ## One Sample t-test ## ## data: x ## t = -2.1281, df = 49, p-value = 0.03838 ## alternative hypothesis: true mean is not equal to 1 ## 95 percent confidence interval: ## -0.182027 0.966136 ## sample estimates: ## mean of x ## 0.3920545 Ugradjena funkcija nam daje vise informacija od same p vrednosti, a p vrednost se poklapa u nasoj funkciji i ugradjenoj. Ugradjena funkcija nam daje i interval poverenja, pa mozemo i to proveriti: confidence_interval(x, 0.95) ## [1] -0.182027 0.966136 Naravno, poklapaju se vrednosti. Pogledajmo kroz ugradjenu funkciju i moguce alternative # H1: m &lt; m_0 t.test(x, mu=1, alternative = &quot;less&quot;) ## ## One Sample t-test ## ## data: x ## t = -2.1281, df = 49, p-value = 0.01919 ## alternative hypothesis: true mean is less than 1 ## 95 percent confidence interval: ## -Inf 0.871 ## sample estimates: ## mean of x ## 0.3920545 ko testiramo \\(H_1 : m &lt; m_0\\), dobijamo vrlo visoku p vrednost, pa cemo da prihvatimo hipotezu \\(H_0: m = 1\\). Primetimo i da interval poverenja koji vrati ova funkcija u slucaju da gledamo jednostrani test je takodje jednostran – leva granica mu je \\(-\\infty\\). Ako testiramo \\(H_1 : m &gt; m_0\\) rezultat je slican t.test(x, mu=1, alternative = &quot;greater&quot;) ## ## One Sample t-test ## ## data: x ## t = -2.1281, df = 49, p-value = 0.9808 ## alternative hypothesis: true mean is greater than 1 ## 95 percent confidence interval: ## -0.08689089 Inf ## sample estimates: ## mean of x ## 0.3920545 Nadalje cemo samo koristiti ugradjene testove u R-u i necemo implementirati svoje. 5.2.2 Slucaj dva uzorka Ukoliko imamo dva nezavisna uzorka \\(X_1,\\dots,X_{n_1}\\) i \\(Y_1,\\dots, Y_{n_2}\\), iz raspodela, redom, \\(\\mathcal{N}(m_1, \\sigma_1)\\) i \\(\\mathcal{N}(m_2, \\sigma_2)\\), za testiranje hipoteze \\[H_0: m_1 = m_2\\] koristimo test statistiku \\[t=\\frac{\\overline{X}_{n_{1}}-\\overline{Y}_{n_{2}}}{\\sqrt{\\frac{\\widetilde{S}_{n_{1}}^{2}}{n_{1}}+\\frac{\\widetilde{S}_{n_{2}}^{2}}{n_{2}}}},\\] koja ima studentovu raspodelu pod \\(H_0\\). Alternativne hipoteze mogu biti kao u slucaju jednog uzorka (\\(m_1&lt;m_2, m_1\\neq m_2, m_1&gt;m_2\\)). Ovaj test se u R-u izvrsava dodajuci jos jedan uzorak u poziv t.test. Primer: x &lt;- rnorm(50) y &lt;- rnorm(35, mean = 2, sd = 4) t.test(x, y) ## ## Welch Two Sample t-test ## ## data: x and y ## t = -3.2342, df = 36.018, p-value = 0.002614 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -3.651159 -0.836842 ## sample estimates: ## mean of x mean of y ## 0.1004483 2.3444487 Ovde dobijamo malu p vrednost (0.002), sto ukazuje na to da treba odbaciti nultu hipotezuu korist alternativne, koja je po default-u \\(H_1:m_1 \\neq m_2\\), sto i pise u izlazu funkcije. Ako bismo testirali sa alternativom \\(H_1:m_1 &gt; m_2\\)… t.test(x, y, alternative = &quot;greater&quot;) ## ## Welch Two Sample t-test ## ## data: x and y ## t = -3.2342, df = 36.018, p-value = 0.9987 ## alternative hypothesis: true difference in means is greater than 0 ## 95 percent confidence interval: ## -3.415402 Inf ## sample estimates: ## mean of x mean of y ## 0.1004483 2.3444487 …dobijena je p vrednost 0.99 sto je jako veliko, pa ne bismo mogli da odbacimo nultu hipotezu! Primetimo, ne znaci da je nulta hipoteza tacna, nego na osnovu dobijenog uzorka, ne mozemo odbaciti nultu hipotezu u korist alternative. 5.2.3 Upareni test Ako obelezja \\(X\\) i \\(Y\\) nisu nezavisna, vec imamo uzorak parova \\((X_1,Y_1),\\dots,(X_n,Y_n)\\) testiranje hipoteze \\(H_0: m_1 = m_2\\) se vrsi uparenim \\(t\\) testom, koji je u R-u implementiran takodje u funkciji t.test, gde se samo doda argument paired = TRUE. x &lt;- rnorm(50, mean = 2) y &lt;- x + rnorm(50, sd = 0.1) # Y nije nezavisno od X nego je X + mali sum t.test(x, y, paired = TRUE) ## ## Paired t-test ## ## data: x and y ## t = 0.3173, df = 49, p-value = 0.7524 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.02659998 0.03657477 ## sample estimates: ## mean of the differences ## 0.004987398 Kao rezultat imamo veliku p vrednost i ne odbacujemo nultu hipotezu. 5.3 Neparametarski testovi 5.3.1 Vilkoksonov test zasnovan na rangovima i znakovima Vilkoksonov test ima slicnu svrhu kao t test, ali pretpostavljamo da je raspodela obelezja \\(X\\) simetricna i zelimo da testiramo \\(H_0 : m = m_0\\), bez pretpostavke normalnosti. Koristimo test statistiku \\[T=\\sum_{i=1}^{n} r_{i} I\\left\\{X_{i}-m_{0} \\geq 0\\right\\}\\], gde su \\(r_i\\) rangovi elemenata \\(|X_i-m_0|\\) u uzorku \\(\\left|X_{1}-m_{0}\\right|, \\ldots,\\left|X_{n}-m_{0}\\right|\\). U R-u je oovaj test implementiran u funkciji wilcox.test. Ova funkcija ima isti interfejs kao t.test (argumente koje prima i slicno). Proverimo test nekim uzorkom iz binomne raspodele \\(\\mathcal{B}(10, 0.3)\\). Trebalo bi da bude ocekivanje \\(3\\). x &lt;- rbinom(50, 10, 0.3) wilcox.test(x, mu = 3) ## Warning in wilcox.test.default(x, mu = 3): cannot compute exact p-value with ## ties ## Warning in wilcox.test.default(x, mu = 3): cannot compute exact p-value with ## zeroes ## ## Wilcoxon signed rank test with continuity correction ## ## data: x ## V = 507.5, p-value = 0.3053 ## alternative hypothesis: true location is not equal to 3 Primenimo ga i na neki uzorak iz t raspodele, za npr. alternativu \\(H_1:m&gt;0\\). x &lt;- rt(20, df = 2) wilcox.test(x, mu = 0, alternative = &quot;greater&quot;) ## ## Wilcoxon signed rank test ## ## data: x ## V = 72, p-value = 0.8919 ## alternative hypothesis: true location is greater than 0 Dakle, ukoliko imamo pretpostavku o normalnoj raspodeli, koristimo t.test, a ukoliko nemamo, wilcox.test moze biti zadovoljavajuci. Kao i t.test i wilcox.test se moze primeniti na 2 uzorka (upareni i neupareni) x &lt;- rexp(50) y &lt;- rexp(30) wilcox.test(x, y) ## ## Wilcoxon rank sum test with continuity correction ## ## data: x and y ## W = 832, p-value = 0.418 ## alternative hypothesis: true location shift is not equal to 0 5.3.2 Kolmogorov–Smirnovljev test saglasnosti sa raspodelom Test Kolmogorov–Smirnova sluzi za testiranje da li se za neki uzorak \\(X_1,\\dots,X_n\\) moze reci da odgovara raspodeli sa funkcijom raspodele \\(F_0\\). Zasnovan je na test statistici \\[T=\\sup _{x}\\left|F_{n}(x)-F_{0}(x)\\right|,\\] gde je \\(F_n\\) empirijska funkcija raspodele uzorka. U R-u je implementiran kroz funkciju ks.test, a kao argumente prima uzorak, kao i funkciju raspodele (funkcije koje obicno pocinju sa p*, npr. pnorm, pexp itd.) Testirajmo da li kolona speed iz skupa podataka cars ima standardnu normalnu raspodelu: x &lt;- cars$speed ks.test(x, &quot;pnorm&quot;) ## Warning in ks.test(x, &quot;pnorm&quot;): ties should not be present for the Kolmogorov- ## Smirnov test ## ## One-sample Kolmogorov-Smirnov test ## ## data: x ## D = 0.99997, p-value &lt; 2.2e-16 ## alternative hypothesis: two-sided p vrednost je prakticno nula, pa odbacujemo nultu hipotezu koja kaze da uzorak ima normalnu \\(\\mathcal{N}(0,1)\\) raspodelu. Mozemo da testiramo da li ima normalnu raspodelu \\(\\mathcal{N}(15,5)\\) (primetite promenjene parametre) ks.test(cars$speed, function(x) pnorm(x, 15, 5)) ## Warning in ks.test(cars$speed, function(x) pnorm(x, 15, 5)): ties should not be ## present for the Kolmogorov-Smirnov test ## ## One-sample Kolmogorov-Smirnov test ## ## data: cars$speed ## D = 0.10575, p-value = 0.631 ## alternative hypothesis: two-sided U ovom slucaju je p vrednost 0.6, sto je vece od \\(\\alpha=0.05\\), pa ne odbacujemo hipotezu koja kaze da je uzorak cars$speed saglasan sa normalnom \\(\\mathcal{N}(15,5)\\) raspodelom. I ovaj test se moze primeniti na testiranje o saglasnosti raspodele dva uzorka, tj. da li 2 uzorka imaju istu raspodelu: Npr. ako imamo dva uzorka iz iste normalne raspodele, ocekujemo visoku p vrednost x &lt;- rnorm(50) y &lt;- rnorm(40) ks.test(x, y) ## ## Two-sample Kolmogorov-Smirnov test ## ## data: x and y ## D = 0.165, p-value = 0.5286 ## alternative hypothesis: two-sided A ako imamo uzorke iz razlicitih raspodela ocekujemo nisku p vrednost… x &lt;- rnorm(50) y &lt;- rexp(40) ks.test(x, y) ## ## Two-sample Kolmogorov-Smirnov test ## ## data: x and y ## D = 0.56, p-value = 6.168e-07 ## alternative hypothesis: two-sided …sto i dobijamo. 5.3.3 \\(\\chi^2\\) test nezavisnosti Konacno, prikazacemo i upotrebu \\(\\chi^2\\) testa koji se koristi za testiranje nezavisnosti dva obelezja \\(X\\) i \\(Y\\), koji je zasnovan na test statistici \\[T=\\sum_{i j} \\frac{\\left(M_{i j}-n \\hat{p}_{i j}\\right)^{2}}{n \\hat{p}_{i j}}.\\] Koristicemo podatke survey iz paketa MASS. U ovom skupu postoje promenljive Smoke i Exer koje se ticu toga da li je student pusac i u kojoj meri, kao i o ucestalosti bavljenja fizickom aktivnoscu. Tabelu kontigencije vidimo i sledecoj tabeli (pozivom funkcije table pravimo tabelu kontigencije). library(MASS) table(survey$Smoke, survey$Exer) ## ## Freq None Some ## Heavy 7 1 3 ## Never 87 18 84 ## Occas 12 3 4 ## Regul 9 1 7 Zanima nas da li postoji zavisnost izmedju cinjenice da je student pusac i nivoa fizicke aktivnosti. Da testiramo hipotezu da su ova dva obelezja nezavisna (nulta hipoteza), mozemo da koristimo funkciju chisq.test: chisq.test(survey$Smoke, survey$Exer) ## Warning in chisq.test(survey$Smoke, survey$Exer): Chi-squared approximation may ## be incorrect ## ## Pearson&#39;s Chi-squared test ## ## data: survey$Smoke and survey$Exer ## X-squared = 5.4885, df = 6, p-value = 0.4828 P vrednost od 0.49 nam ukazuje da ne mozemo da odbacimo nultu hipotezu o nezavisnosti, tako da nemamo dokaza da tvrdimo da postoji veza izmedju pusenja i fizicke aktivnosti. "]
]
